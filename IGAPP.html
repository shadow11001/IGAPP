<!DOCTYPE html>
<!-- Version: 1.0.0 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Walmart Digital Assets QA Checklist and Notes Application">
    <title>Walmart Digital Assets - QA Checklist</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }

        body.light-mode {
            background-color: #ffffff;
            color: #000000;
        }

        body.dark-mode {
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .form-container {
            max-width: 1200px;
            width: 90%;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            transition: background-color 0.3s, border-color 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        @media (max-width: 768px) {
            .form-container {
                width: 95%;
                margin: 10px auto;
                padding: 15px;
                gap: 15px;
            }
            .form-section, .qa-container {
                min-width: 100%;
            }
        }

        body.light-mode .form-container {
            background: #f9f9f9;
            border-color: #ccc;
        }

        body.dark-mode .form-container {
            background: #2c2c2c;
            border-color: #555;
        }

        .form-section {
            flex: 2;
            min-width: 400px;
            order: 2;
        }

        .qa-container {
            flex: 1;
            min-width: 300px;
            order: 1;
        }        .qa-container h4 {
            margin: 15px 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            border-bottom: 1px solid #ddd;
            padding-bottom: 4px;
        }

        body.dark-mode .qa-container h4 {
            color: #ccc;
            border-bottom-color: #555;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .quick-note-btn {
            padding: 6px 10px;
            font-size: 12px;
            min-height: 28px;
            margin: 0;
            border-radius: 4px;
            flex: 0 0 auto;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .quick-note-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .success-quick {
            background-color: #28a745 !important;
            color: white !important;
        }

        .success-quick:hover {
            background-color: #218838 !important;
        }

        .error-quick {
            background-color: #dc3545 !important;
            color: white !important;
        }

        .error-quick:hover {
            background-color: #c82333 !important;
        }        textarea, input, select {
            width: 100%;
            margin-top: 10px;
            padding: 5px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body.light-mode textarea,
        body.light-mode input,
        body.light-mode select {
            background-color: #ffffff;
            color: #000000;
            border: 1px solid #ccc;
        }

        body.dark-mode textarea,
        body.dark-mode input,
        body.dark-mode select {
            background-color: #333;
            color: #ffffff;
            border: 1px solid #666;
        }

        textarea {
            height: 70px;
        }

        button {
            margin-top: 10px;
            margin-right: 10px;
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            min-height: 36px;
        }

        button:focus {
            outline: 2px solid #007bff;
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .success-feedback {
            background-color: #28a745 !important;
            transform: scale(0.98);
        }

        .error-feedback {
            background-color: #dc3545 !important;
            transform: scale(0.98);
        }

        body.light-mode button {
            background-color: #007bff;
            color: #ffffff;
        }

        body.dark-mode button {
            background-color: #555;
            color: #ffffff;
        }

        body.light-mode button:hover {
            background-color: #0056b3;
        }

        body.dark-mode button:hover {
            background-color: #777;
        }

        .qa-container p {
            margin-bottom: 5px;
        }



        .notification {
            position: fixed;
            top: 60px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background-color: #28a745;
        }

        .notification.error {
            background-color: #dc3545;
        }

        .loading {
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .danger-button {
            background-color: #dc3545 !important;
        }

        .danger-button:hover {
            background-color: #c82333 !important;
        }

        .primary-button {
            background-color: #007bff !important;
            color: #ffffff !important;
        }

        .primary-button:hover {
            background-color: #0056b3 !important;
        }

        .success-button {
            background-color: #28a745 !important;
            color: #ffffff !important;
        }

        .success-button:hover {
            background-color: #218838 !important;
        }

        .theme-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            font-size: 1.5em;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .theme-toggle i {
            color: #ffffff;
        }

        .dead-air-timer {
            position: fixed;
            top: 10px;
            right: 70px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            justify-content: center;
        }

        .dead-air-timer.warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            animation: pulse-warning 1s infinite;
        }

        .dead-air-timer.critical {
            background: linear-gradient(135deg, #dc3545 0%, #e74c3c 100%);
            animation: flash-critical 0.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes flash-critical {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .timer-controls {
            display: flex;
            gap: 4px;
        }

        .timer-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .timer-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .mic-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
            transition: background 0.3s;
        }

        .mic-status.active {
            background: #28a745;
            animation: pulse-mic 2s infinite;
        }

        @keyframes pulse-mic {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        small {
            display: block;
            margin-top: 4px;
            font-size: 12px;
            opacity: 0.7;
        }

        .tag-recommendations {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        body.light-mode .tag-recommendations {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        body.dark-mode .tag-recommendations {
            background: #343a40;
            border-color: #495057;
        }

        .tag-recommendations h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        body.dark-mode .tag-recommendations h4 {
            color: #ccc;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 24px;
            align-items: center;
        }

        .tag-item {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            user-select: none;
        }

        .tag-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tag-item.high-confidence {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            font-weight: 500;
        }

        .tag-item.medium-confidence {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            font-weight: 500;
        }

        .tag-item.low-confidence {
            background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%);
            color: white;
        }

        .tag-item.selected {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.3);
        }

        .tag-confidence-legend {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 8px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .tag-confidence-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-confidence-legend .legend-color {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }

        .legend-high { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }
        .legend-medium { background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%); }
        .legend-low { background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%); }

        .infraction-tracker {
            position: fixed;
            top: 70px;
            right: 10px;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .infraction-session, .infraction-total {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .infraction-session {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 4px;
        }

        .infraction-total {
            padding-top: 2px;
        }

        .infraction-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: background 0.2s;
            min-width: 20px;
        }

        .infraction-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .infraction-tracker.has-infractions {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse-infractions 2s infinite;
        }

        @keyframes pulse-infractions {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
    </style>
</head>
<body class="light-mode">
    <div class="dead-air-timer" id="dead-air-timer">
        <div class="mic-status" id="mic-status" title="Microphone status"></div>
        <span id="timer-display">00:00</span>
        <div class="timer-controls">
            <button class="timer-btn" onclick="resetTimer()" title="I Spoke / Reset">üó£</button>
            <button class="timer-btn" onclick="toggleAutoStart()" title="Toggle Auto-Start">ü§ñ</button>
        </div>
    </div>
    
    <div class="infraction-tracker" id="infraction-tracker">
        <div class="infraction-session">
            <span>Session: </span>
            <span id="session-count">0</span>
            <button class="infraction-btn" onclick="clearLastInfraction()" title="Clear Last Infraction">‚ùå</button>
        </div>
        <div class="infraction-total">
            <span>Total: </span>
            <span id="total-count">0</span>
            <button class="infraction-btn" onclick="clearTotalInfractions()" title="Clear Total Count">üóëÔ∏è</button>
        </div>
    </div>
    
    <button class="theme-toggle" aria-label="Toggle between light and dark mode" onclick="toggleTheme()" id="theme-toggle-btn" tabindex="0">
        <i class="fas fa-sun" id="theme-toggle-icon" aria-hidden="true"></i>
    </button>

    <div class="form-container">
        <!-- Quick Notes Buttons on the Left -->
        <div class="qa-container">
            <h3>Quick Notes</h3>
            
            <h4>System Login</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Logged into Novar.')" class="quick-note-btn" title="Novar Login">Novar</button>
                <button onclick="addQuickNote('Logged into Opus Arch.')" class="quick-note-btn" title="Opus Arch Login">Opus Arch</button>
                <button onclick="addQuickNote('Logged into Opus Mag.')" class="quick-note-btn" title="Opus Mag Login">Opus Mag</button>
                <button onclick="addQuickNote('Logged into CPC.')" class="quick-note-btn" title="CPC Login">CPC</button>
                <button onclick="addQuickNote('Logged into Danfoss AKA65.')" class="quick-note-btn" title="Danfoss AKA65 Login">AKA65</button>
                <button onclick="addQuickNote('Logged into Danfoss Storeview.')" class="quick-note-btn" title="Danfoss Storeview Login">Storeview</button>
            </div>

            <h4>Diagnostics</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Checked comms.')" class="quick-note-btn" title="Communications Check">Comms ‚úì</button>
                <button onclick="addQuickNote('Checked comms. Still in comm loss.')" class="quick-note-btn" title="Communications Loss">Comms ‚úó</button>
                <button onclick="addQuickNote('Checked temps.')" class="quick-note-btn" title="Temperature Check">Temps</button>
                <button onclick="addQuickNote('Checked alarms.')" class="quick-note-btn" title="Alarm Check">Alarms</button>
                <button onclick="addQuickNote('Checked clocks.')" class="quick-note-btn" title="Clock Check">Clocks</button>
                <button onclick="addQuickNote('Pinged controller.')" class="quick-note-btn" title="Ping Test">Ping</button>
                <button onclick="addTestNote()" class="quick-note-btn" title="Test Component">Test</button>
            </div>

            <h4>Ping Results</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Receiving good ping.')" class="quick-note-btn success-quick" title="Successful Ping">Good Ping</button>
                <button onclick="addQuickNote('Ping timedout.')" class="quick-note-btn error-quick" title="Failed Ping">Ping Timeout</button>
            </div>

            <h4>Actions</h4>
            <div class="button-group">
                <button onclick="addQuickNoteWithInput('Forced defrost on ', 'Enter rack/unit:')" class="quick-note-btn" title="Force Defrost">Defrost</button>
                <button onclick="addQuickNote('Terminated Defrost.')" class="quick-note-btn" title="Stop Defrost">Stop Defrost</button>
                <button onclick="addQuickNoteWithInput('Forced on ', 'Enter equipment:')" class="quick-note-btn" title="Force Equipment On">Force On</button>
                <button onclick="addForcedNote()" class="quick-note-btn" title="Force Parameter">Forced</button>
                <button onclick="addForcedOffNote()" class="quick-note-btn" title="Force Off Previously Forced Item">Forced Off</button>
                <button onclick="addQuickNote('Forced on lights.')" class="quick-note-btn" title="Force Lights On">Lights On</button>
                <button onclick="addSetpointNote()" class="quick-note-btn" title="Change Temperature Setpoint">Setpoint</button>
                <button onclick="addQuickNote('Reset clocks.')" class="quick-note-btn" title="Reset System Clocks">Reset Clocks</button>
            </div>

            <h4>Downloads</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Performed Version Download.')" class="quick-note-btn" title="Version Download">Version</button>
                <button onclick="addQuickNote('Performed Load Change Download.')" class="quick-note-btn" title="Load Change Download">Load Change</button>
                <button onclick="addQuickNote('Performed Comms and Load Change Download.')" class="quick-note-btn" title="Comms + Load Change">Comms+LC</button>
                <button onclick="addQuickNote('Performed Main and Load Change Download.')" class="quick-note-btn" title="Main + Load Change">Main+LC</button>
                <button onclick="addQuickNote('Performed Main, Comms, and Load Change Download.')" class="quick-note-btn" title="Full Download">Full DL</button>
            </div>

            <h4>Call Status</h4>
            <div class="button-group">
                <button onclick="addQuickNote('All good.')" class="quick-note-btn success-quick" title="Everything Working">All Good</button>
                <button onclick="addQuickNote('No good.')" class="quick-note-btn error-quick" title="Issue Persists">No Good</button>
                <button onclick="addQuickNote('Tech will troubleshoot.')" class="quick-note-btn" title="Tech Troubleshooting">Tech T/S</button>
                <button onclick="addQuickNote('Tech no longer needed assistance.')" class="quick-note-btn success-quick" title="Call Complete">Call Done</button>
                <button onclick="addEscalateNote()" class="quick-note-btn" title="Escalate with DAE and WO">Escalate</button>
            </div>

            <h4>Special Cases</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Call dropped.')" class="quick-note-btn error-quick" title="Call Disconnected">Call Dropped</button>
                <button onclick="addQuickNote('Tech called for a suppression. Adv tech of NSRM email.')" class="quick-note-btn" title="Suppression Request">NSRM</button>
                <button onclick="addQuickNote('Adv tech to power cycle controller.')" class="quick-note-btn" title="Power Cycle Recommendation">Power Cycle</button>
            </div>

            <h4>Recommendations</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Advised to monitor and call back if issues persist.')" class="quick-note-btn" title="Monitor Instruction">Monitor</button>
                <button onclick="showContactOptions()" class="quick-note-btn" title="Contact Instruction">Contact</button>
                <button onclick="addReplaceNote()" class="quick-note-btn" title="Replace Instruction">Replace</button>
            </div>
        </div>

        <!-- Form Fields on the Right -->
        <div class="form-section">
            <h1>Notes</h1>

            <label for="history">View Previous Notes:</label>
            <select id="history" onchange="restoreNotes()" aria-describedby="history-help">
                <option value="">-- Select Previous Notes --</option>
            </select>
            <small id="history-help" class="sr-only">Select from previously saved notes from the last 7 days</small>

            <label for="tech-name">Technician Name:</label>
            <input type="text" id="tech-name" placeholder="Enter technician name" aria-required="false" autocomplete="name">

            <label for="store-number">Store Number:</label>
            <input type="number" id="store-number" placeholder="Enter store number" aria-required="false" inputmode="numeric">

            <label for="work-order">Work Order Number:</label>
            <input type="text" id="work-order" placeholder="Enter work order number" aria-required="false">

            <label for="autofill">Select a DAE:</label>
            <select id="autofill" onchange="updateNotes()" aria-describedby="autofill-help">
                <option value="">-- Select an Option --</option>
                <option value="Help Desk Post">Help Desk Post</option>
                <option value="Condenser and Compressor Staging Changes">Condenser and Compressor Staging Changes</option>
                <option value="Changes to Rack Suction Settings">Changes to Rack Suction Settings</option>
                <option value="Reporting Issues with IoT">Reporting Issues with IoT</option>
                <option value="Setting MAC Addresses">Setting MAC Addresses for Controller Replacements</option>
                <option value="Controller COMM Loss">Controller COMM Loss Related to Network & Cabling</option>
                <option value="Changing Board Points">Changing Board Points in Danfoss or CPC</option>
                <option value="Carel BOSS Support">Calls, alarms, or emails related to Carel BOSS controllers</option>
                <option value="Novar Download Failures">Novar Downloads that Failed After Second Attempt</option>
                <option value="Danfoss Downloads">Downloads for any Danfoss controller</option>
                <option value="Manager Escalations">Manager Escalations</option>
                <option value="Program Change Request">Program Change Request</option>
                <option value="RTU Fans Mode">Taking RTU Fans Out Of Continuous Mode</option>
                <option value="Parameter Deviation">Parameter Deviation Request</option>
                <option value="Swap Work Order">Swap Work Order</option>
                <option value="Mastermind Work Order">Mastermind Work Order</option>
            </select>

            <label for="dropdown-notes">DAE:</label>
            <textarea id="dropdown-notes" placeholder="Selecting a dropdown will load a template here. If this box is not empty, you will be asked to confirm before overwriting." aria-describedby="dae-help"></textarea>
            <small id="dae-help" class="sr-only">Template text for Digital Asset Expert procedures</small>
            <small id="autofill-help" class="sr-only">Selecting an option will populate the DAE textarea with template text</small>
            <button onclick="copyToClipboard(event, 'dropdown-notes')" aria-describedby="copy-dae-help" class="primary-button">Copy DAE</button>
            <small id="copy-dae-help" class="sr-only">Copy DAE template text to clipboard</small>

            <label for="notes">Your Call Notes:</label>
            <textarea id="notes" placeholder="Enter your call notes here..." aria-describedby="notes-help"></textarea>
            <small id="notes-help" class="sr-only">Enter additional notes about the call. This will be combined with technician information when copied.</small>
            <button onclick="copyAdditionalNotes(event)" aria-describedby="copy-notes-help" class="success-button">Copy Notes</button>
            <small id="copy-notes-help" class="sr-only">Copy all form data including technician info and notes to clipboard</small>
            <button onclick="clearFormFields()" aria-describedby="clear-form-help" class="primary-button">Clear Form</button>
            <small id="clear-form-help" class="sr-only">Clear all form fields but keep history</small>
            <button onclick="clearForm()" aria-describedby="clear-all-help" class="danger-button">Clear Everything</button>
            <small id="clear-all-help" class="sr-only">Clear all form fields and delete all saved history</small>
            
            <div id="tag-recommendations" class="tag-recommendations">
                <h4>Recommended Tags</h4>
                <div id="recommended-tags" class="tag-list">
                    <small>Tags will appear here based on your notes content...</small>
                </div>
            </div>
        </div>
    </div>

<!-- Templates are now managed in JavaScript for maintainability -->

    <script>
        // Global state management
        const AppState = {
            autoSaveTimer: null,
            lastSavedData: null,
            deadAirTimer: null,
            deadAirSeconds: 0,
            timerRunning: false,
            micStream: null,
            speakerStream: null,
            micAudioContext: null,
            speakerAudioContext: null,
            micAnalyser: null,
            speakerAnalyser: null,
            micActive: false,
            callDetected: false,
            autoStartEnabled: true,
            loudSoundThreshold: 80, // Higher threshold for call detection (speakers)
            speechThreshold: 25,    // Lower threshold for voice detection (microphone)
            selectedTags: new Set(),
            sessionInfractions: 0,  // Resets each call
            totalInfractions: 0,    // Persists across calls
            deadAirThreshold: 30    // Seconds before infraction
        };

        // Tag analysis system
        const TAG_KEYWORDS = {
            'Call Dropped Mid Call': ['call dropped', 'dropped', 'disconnected', 'lost connection'],
            'Caller Couldn\'t Hear Me': ['couldn\'t hear me', 'can\'t hear me', 'audio issues', 'mic problems'],
            'Carel': ['carel', 'boss'],
            'Couldn\'t Hear Caller': ['couldn\'t hear', 'can\'t hear caller', 'audio problems', 'static'],
            'Comms': ['comm loss', 'communication loss', 'network', 'ethernet', 'comms', 'communication'],
            'CPC': ['cpc'],
            'DAE': ['dae', 'escalat', 'work order', 'wo'],
            'Danfoss AKA65': ['aka65', 'aka'],
            'Danfoss SVD': ['svd', 'storeview'],
            'Defrost': ['defrost', 'forced defrost', 'terminated defrost'],
            'Download': ['download', 'version download', 'load change download', 'main download', 'comms download', 'full dl', 'performed download'],
            'Duplicate': ['duplicate', 'already called', 'repeat'],
            'Electrician Request': ['electrician', 'electrical', 'power issue'],
            'EMS': ['ems', 'system'],
            'Equipment Request': ['equipment', 'replace', 'new'],
            'Fuel Request': ['fuel', 'generator fuel'],
            'HVAC': ['hvac', 'air conditioning', 'heating', 'rtu'],
            'Lighting': ['lights', 'lighting', 'forced on lights'],
            'Manager Escalation': ['manager', 'escalation', 'supervisor'],
            'Mobile Gen Staging': ['mobile gen', 'generator staging'],
            'Monitoring (Mobile Gen)': ['monitor', 'mobile gen'],
            'Monitoring (PMG)': ['monitor', 'pmg'],
            'New Module': ['new module', 'module'],
            'No Reply Needed': ['no reply', 'information only'],
            'Novar ESS': ['novar', 'ess'],
            'Opus Architect': ['opus arch', 'architect'],
            'Opus Magnum': ['opus mag', 'magnum'],
            'Other': ['other', 'misc', 'various'],
            'PMG Request': ['pmg'],
            'Point Change': ['point change', 'board point', 'changing board'],
            'Power Alerts Change Request': ['power alert', 'alert change'],
            'Power Cycle': ['power cycle', 'restart', 'reboot'],
            'Power Restoral Emails': ['power restoral', 'power restored'],
            'PPO': ['ppo'],
            'Project': ['project'],
            'Queue Cap': ['queue cap', 'capacity'],
            'Really Distant/Underwater': ['distant', 'underwater', 'poor connection', 'bad line'],
            'Refrigeration': ['refrigeration', 'rack', 'cooling', 'temps', 'temperature', 'defrost', 'forced defrost', 'terminated defrost'],
            'Refrigeration Tech Request': ['refrigeration tech', 'ref tech'],
            'Remodel': ['remodel', 'renovation'],
            'Reroute': ['reroute', 'redirect'],
            'Set Points': ['setpoint', 'set point', 'temperature setting'],
            'Site Emergency': ['emergency', 'urgent', 'critical'],
            'Sporlan': ['sporlan'],
            'Static': ['static', 'noise', 'interference'],
            'Suppression': ['suppression', 'nsrm'],
            'Test': ['test', 'testing', 'tested'],
            'Unplanned Power Outage': ['power outage', 'outage', 'power loss'],
            'Utility Notification': ['utility', 'notification'],
            'Sams': ['sams', 'sam\'s club']
        };

        function analyzeNotesForTags() {
            const notesContent = document.getElementById('notes').value.toLowerCase();
            const daeContent = document.getElementById('dropdown-notes').value.toLowerCase();
            const combinedContent = (notesContent + ' ' + daeContent).trim();
            
            if (!combinedContent) {
                displayRecommendedTags([]);
                return;
            }
            
            const tagScores = {};
            
            // Analyze content for tag keywords
            for (const [tag, keywords] of Object.entries(TAG_KEYWORDS)) {
                let score = 0;
                let matchCount = 0;
                
                keywords.forEach(keyword => {
                    const regex = new RegExp('\\b' + keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                    const matches = combinedContent.match(regex);
                    if (matches) {
                        matchCount += matches.length;
                        score += matches.length * (keyword.length > 3 ? 2 : 1); // Longer keywords get more weight
                    }
                });
                
                if (score > 0) {
                    tagScores[tag] = { score, matchCount };
                }
            }
            
            // Sort tags by score and determine confidence levels
            const sortedTags = Object.entries(tagScores)
                .sort(([,a], [,b]) => b.score - a.score)
                .slice(0, 8) // Show top 8 recommendations
                .map(([tag, data]) => {
                    let confidence = 'low';
                    if (data.score >= 4 || data.matchCount >= 3) confidence = 'high';
                    else if (data.score >= 2 || data.matchCount >= 2) confidence = 'medium';
                    
                    return { tag, confidence, score: data.score };
                });
            
            displayRecommendedTags(sortedTags);
        }

        function displayRecommendedTags(tags) {
            const tagContainer = document.getElementById('recommended-tags');
            
            if (tags.length === 0) {
                tagContainer.innerHTML = '<small>Tags will appear here based on your notes content...</small>';
                return;
            }
            
            const tagElements = tags.map(({ tag, confidence }) => {
                const isSelected = AppState.selectedTags.has(tag);
                return `<span class="tag-item ${confidence}-confidence ${isSelected ? 'selected' : ''}" 
                              onclick="toggleTag('${tag.replace(/'/g, '\\\'')}')" 
                              title="Click to select/deselect this tag">
                            ${tag}
                        </span>`;
            }).join('');
            
            const legend = `
                <div class="tag-confidence-legend">
                    <span><div class="legend-color legend-high"></div>High confidence</span>
                    <span><div class="legend-color legend-medium"></div>Medium confidence</span>
                    <span><div class="legend-color legend-low"></div>Low confidence</span>
                </div>
            `;
            
            tagContainer.innerHTML = tagElements + legend;
        }

        function toggleTag(tagName) {
            if (AppState.selectedTags.has(tagName)) {
                AppState.selectedTags.delete(tagName);
            } else {
                AppState.selectedTags.add(tagName);
            }
            
            // Update visual state
            const tagElements = document.querySelectorAll('.tag-item');
            tagElements.forEach(element => {
                if (element.textContent.trim() === tagName) {
                    element.classList.toggle('selected');
                }
            });
            
            // Show notification
            const action = AppState.selectedTags.has(tagName) ? 'Selected' : 'Deselected';
            showNotification(`${action} tag: ${tagName}`, 'success', 1500);
        }

        function getSelectedTags() {
            return Array.from(AppState.selectedTags);
        }

        // Dead Air Timer Functions
        function startTimer() {
            if (!AppState.timerRunning) {
                // Clear any existing timer first
                if (AppState.deadAirTimer) {
                    clearInterval(AppState.deadAirTimer);
                    AppState.deadAirTimer = null;
                }
                
                AppState.timerRunning = true;
                AppState.deadAirTimer = setInterval(updateTimer, 1000);
                showNotification('Dead air timer started', 'success', 1500);
            }
        }

        function pauseTimer() {
            AppState.timerRunning = false;
            if (AppState.deadAirTimer) {
                clearInterval(AppState.deadAirTimer);
                AppState.deadAirTimer = null;
            }
            showNotification('Timer paused', 'success', 1500);
        }

        function resetTimer() {
            AppState.deadAirSeconds = 0;
            updateTimerDisplay();
            updateTimerVisuals();
            showNotification('Timer reset - You spoke!', 'success', 1000);
        }

        function updateTimer() {
            if (AppState.timerRunning) {
                AppState.deadAirSeconds++;
                updateTimerDisplay();
                updateTimerVisuals();
                
                // Check for infraction at 30 seconds
                if (AppState.deadAirSeconds === AppState.deadAirThreshold) {
                    recordInfraction();
                }
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(AppState.deadAirSeconds / 60);
            const seconds = AppState.deadAirSeconds % 60;
            const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer-display').textContent = display;
        }

        function updateTimerVisuals() {
            const timer = document.getElementById('dead-air-timer');
            timer.classList.remove('warning', 'critical');
            
            if (AppState.deadAirSeconds >= 30) {
                timer.classList.add('critical');
            } else if (AppState.deadAirSeconds >= 25) {
                timer.classList.add('warning');
            }
        }

        // Microphone Detection (for voice detection only)
        async function initializeMicrophone() {
            try {
                console.log('Attempting to initialize microphone...');
                
                // Get microphone for voice detection
                AppState.micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                console.log('Microphone access granted');
                
                AppState.micAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                AppState.micAnalyser = AppState.micAudioContext.createAnalyser();
                const micSource = AppState.micAudioContext.createMediaStreamSource(AppState.micStream);
                micSource.connect(AppState.micAnalyser);
                
                AppState.micAnalyser.fftSize = 256;
                AppState.micAnalyser.smoothingTimeConstant = 0.8;
                
                console.log('Audio context created, starting voice detection...');
                startVoiceDetection();
                
                // Try to get speaker/system audio for call detection
                initializeSpeakerDetection();
                
            } catch (error) {
                console.error('Microphone initialization failed:', error);
                showNotification('Microphone access denied - Using manual controls only', 'error', 3000);
            }
        }

        async function initializeSpeakerDetection() {
            try {
                // Try to capture system audio (speakers) - this requires screen sharing permission
                AppState.speakerStream = await navigator.mediaDevices.getDisplayMedia({
                    video: false,
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        systemAudio: 'include'  // Try to include system audio
                    }
                });
                
                // Check if we actually got audio
                const audioTracks = AppState.speakerStream.getAudioTracks();
                if (audioTracks.length === 0) {
                    throw new Error('No audio tracks in display media');
                }
                
                AppState.speakerAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                AppState.speakerAnalyser = AppState.speakerAudioContext.createAnalyser();
                const speakerSource = AppState.speakerAudioContext.createMediaStreamSource(AppState.speakerStream);
                speakerSource.connect(AppState.speakerAnalyser);
                
                AppState.speakerAnalyser.fftSize = 512;
                AppState.speakerAnalyser.smoothingTimeConstant = 0.3;
                
                startCallDetection();
                showNotification('ÔøΩ Speaker audio enabled - Auto call detection active!', 'success', 3000);
                
            } catch (error) {
                console.warn('Speaker audio access not available:', error);
                showNotification('üîä Speaker detection unavailable - Manual start only', 'error', 3000);
                // Fall back to manual controls only
            }
        }

        function startVoiceDetection() {
            const bufferLength = AppState.micAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function detectVoice() {
                if (!AppState.micAnalyser) return;
                
                AppState.micAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                
                const wasSpeaking = AppState.micActive;
                AppState.micActive = average > AppState.speechThreshold;
                
                // Update mic status indicator
                const micStatus = document.getElementById('mic-status');
                if (AppState.micActive) {
                    micStatus.classList.add('active');
                    // Auto-reset timer when your voice is detected
                    if (!wasSpeaking && AppState.timerRunning) {
                        resetTimer();
                    }
                } else {
                    micStatus.classList.remove('active');
                }
                
                requestAnimationFrame(detectVoice);
            }
            
            detectVoice();
            showNotification('üé§ Voice detection active', 'success', 2000);
        }

        function startCallDetection() {
            const bufferLength = AppState.speakerAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            let loudSoundCount = 0;
            let lastLoudSoundTime = 0;
            
            function detectCall() {
                if (!AppState.speakerAnalyser) return;
                
                AppState.speakerAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                const currentTime = Date.now();
                
                // Detect loud sounds from speakers (beep + announcement)
                const isLoudSound = average > AppState.loudSoundThreshold;
                
                // Auto-start timer when call is detected
                if (!AppState.callDetected && AppState.autoStartEnabled) {
                    if (isLoudSound) {
                        loudSoundCount++;
                        lastLoudSoundTime = currentTime;
                        
                        // If we detect sustained loud audio (beep + announcement)
                        if (loudSoundCount >= 3 && !AppState.timerRunning) {
                            AppState.callDetected = true;
                            startTimer();
                            showNotification('üìû Call detected - Timer started automatically!', 'success', 3000);
                        }
                    } else {
                        // Reset if silence for too long
                        if (currentTime - lastLoudSoundTime > 3000) {
                            loudSoundCount = 0;
                        }
                    }
                }
                
                requestAnimationFrame(detectCall);
            }
            
            detectCall();
        }

        function toggleAutoStart() {
            AppState.autoStartEnabled = !AppState.autoStartEnabled;
            const status = AppState.autoStartEnabled ? 'enabled' : 'disabled';
            showNotification(`Auto-start on call detection ${status}`, 'success', 2000);
        }

        function resetCallDetection() {
            AppState.callDetected = false;
            AppState.timerRunning = false;
            AppState.deadAirSeconds = 0;
            
            // Clear the timer interval
            if (AppState.deadAirTimer) {
                clearInterval(AppState.deadAirTimer);
                AppState.deadAirTimer = null;
            }
            
            // Clear session infractions at end of call
            AppState.sessionInfractions = 0;
            updateInfractionDisplay();
            
            updateTimerDisplay();
            updateTimerVisuals();
            showNotification('Call ended - Timer stopped and reset', 'success', 2000);
        }

        // Infraction tracking functions
        function recordInfraction() {
            AppState.sessionInfractions++;
            AppState.totalInfractions++;
            
            // Save total to localStorage
            localStorage.setItem('totalInfractions', AppState.totalInfractions.toString());
            
            updateInfractionDisplay();
            showNotification('‚ö†Ô∏è Dead air infraction recorded (30+ seconds)', 'error', 3000);
        }

        function clearLastInfraction() {
            if (AppState.sessionInfractions > 0) {
                AppState.sessionInfractions--;
                AppState.totalInfractions--;
                
                // Update localStorage
                localStorage.setItem('totalInfractions', AppState.totalInfractions.toString());
                
                updateInfractionDisplay();
                showNotification('‚úÖ Last infraction cleared', 'success', 2000);
            } else {
                showNotification('‚ùå No infractions to clear', 'error', 2000);
            }
        }

        function clearTotalInfractions() {
            if (confirm('Clear all total infractions? This cannot be undone.')) {
                AppState.totalInfractions = 0;
                localStorage.setItem('totalInfractions', '0');
                updateInfractionDisplay();
                showNotification('üóëÔ∏è Total infractions cleared', 'success', 2000);
            }
        }

        function updateInfractionDisplay() {
            const sessionCount = document.getElementById('session-count');
            const totalCount = document.getElementById('total-count');
            const tracker = document.getElementById('infraction-tracker');
            
            if (sessionCount) sessionCount.textContent = AppState.sessionInfractions;
            if (totalCount) totalCount.textContent = AppState.totalInfractions;
            
            // Add visual emphasis when there are infractions
            if (tracker) {
                if (AppState.sessionInfractions > 0) {
                    tracker.classList.add('has-infractions');
                } else {
                    tracker.classList.remove('has-infractions');
                }
            }
        }

        function loadTotalInfractions() {
            const saved = localStorage.getItem('totalInfractions');
            if (saved) {
                AppState.totalInfractions = parseInt(saved) || 0;
            }
        }

        // VCC Integration Methods
        function initializeVCCIntegration() {
            console.log('Initializing VCC integration...');
            
            // Method 1: VCC Audio monitoring (if microphone available)
            if (AppState.micAnalyser) {
                console.log('Microphone analyser available, starting VCC audio monitoring');
                monitorVCCAudio();
            } else {
                console.log('No microphone analyser available yet');
                // Try again after a short delay
                setTimeout(() => {
                    if (AppState.micAnalyser) {
                        console.log('Microphone analyser now available, starting VCC audio monitoring');
                        monitorVCCAudio();
                    } else {
                        console.log('Microphone analyser still not available');
                    }
                }, 2000);
            }
            
            // Method 2: Add VCC call control button
            addVCCManualButton();
            
            console.log('VCC integration methods initialized');
        }

        function initializeVCCWindowDetection() {
            let windowFocusLost = null;
            let windowBlurCount = 0;
            
            // Monitor rapid window focus changes (VCC often steals focus)
            window.addEventListener('blur', function() {
                windowFocusLost = Date.now();
                windowBlurCount++;
                console.log('Window blur detected, count:', windowBlurCount);
                
                // If multiple rapid blurs, might be VCC activity
                setTimeout(() => {
                    if (windowBlurCount >= 2) {
                        showNotification('üîÑ Multiple window changes - VCC activity detected?', 'success', 3000);
                        windowBlurCount = 0;
                    }
                }, 3000);
            });
            
            window.addEventListener('focus', function() {
                if (windowFocusLost) {
                    const focusTime = Date.now() - windowFocusLost;
                    console.log('Window focus returned after:', focusTime, 'ms');
                    
                    // If focus was lost for a typical call duration (5+ seconds)
                    if (focusTime > 5000 && focusTime < 30000) {
                        showNotification('ÔøΩ Focus returned - Was that a VCC call?', 'success', 3000);
                    }
                    windowFocusLost = null;
                }
            });
            
            // Monitor for page visibility changes (VCC switching tabs)
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    console.log('Page hidden - VCC might be active');
                } else {
                    console.log('Page visible - Back from VCC?');
                    showNotification('üëÄ Page visible - Back from VCC call?', 'success', 2000);
                }
            });
        }

        function addVCCManualButton() {
            // Add VCC call control button to timer controls
            const timerControls = document.querySelector('.timer-controls');
            if (timerControls && !document.getElementById('vcc-manual-btn')) {
                const vccButton = document.createElement('button');
                vccButton.id = 'vcc-manual-btn';
                vccButton.className = 'timer-btn';
                vccButton.onclick = toggleVCCMode;
                vccButton.title = 'Start VCC Call';
                vccButton.textContent = 'VCC';
                timerControls.appendChild(vccButton);
            }
        }

        function toggleVCCMode() {
            if (!AppState.timerRunning) {
                // Start VCC call mode
                startTimer();
                AppState.callDetected = true;
                const btn = document.getElementById('vcc-manual-btn');
                if (btn) {
                    btn.textContent = 'END';
                    btn.style.background = 'rgba(220, 53, 69, 0.3)';
                    btn.title = 'End VCC Call';
                }
                showNotification('üìû VCC Call Started', 'success', 2000);
            } else {
                // End VCC call mode  
                resetCallDetection();
                const btn = document.getElementById('vcc-manual-btn');
                if (btn) {
                    btn.textContent = 'VCC';
                    btn.style.background = '';
                    btn.title = 'Start VCC Call';
                }
                showNotification('üìû VCC Call Ended', 'success', 2000);
            }
        }

        function monitorVCCAudio() {
            console.log('Starting VCC audio monitoring...');
            
            const bufferLength = AppState.micAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            let callBeepDetected = false;
            let consecutiveHighAudio = 0;
            let lastAudioLevel = 0;
            let logCount = 0;
            
            function detectVCCCall() {
                if (!AppState.micAnalyser) {
                    console.log('No mic analyser available');
                    return;
                }
                
                AppState.micAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                
                // Debug: Log audio levels more frequently initially, then every 5 seconds
                logCount++;
                if (logCount <= 20 || logCount % 50 === 0) {
                    console.log(`Audio level: ${Math.round(average)}, Threshold: 60, High threshold: 30, Buffer length: ${bufferLength}`);
                }
                
                // Also log when there are significant changes
                if (Math.abs(average - lastAudioLevel) > 10) {
                    console.log(`Audio level changed: ${Math.round(lastAudioLevel)} ‚Üí ${Math.round(average)}`);
                    lastAudioLevel = average;
                }
                
                // VCC high audio detection (original threshold)
                if (average > 60) {
                    consecutiveHighAudio++;
                    console.log(`HIGH audio detected: ${Math.round(average)}, consecutive: ${consecutiveHighAudio}`);
                    
                    if (consecutiveHighAudio >= 3 && !AppState.timerRunning && AppState.autoStartEnabled) {
                        console.log('üéØ VCC CALL DETECTED - Starting timer!');
                        showNotification('üìû VCC audio spike detected - Starting timer!', 'success', 3000);
                        startTimer();
                        callBeepDetected = true;
                    }
                } else if (average > 30) {
                    // Medium audio detection (lower threshold)
                    if (consecutiveHighAudio > 0 || average > 40) {
                        console.log(`MEDIUM audio detected: ${Math.round(average)}`);
                        showNotification('üéµ Audio activity - Possible VCC call', 'success', 2000);
                    }
                    consecutiveHighAudio = Math.max(0, consecutiveHighAudio - 1);
                } else if (average > 15) {
                    // Low audio detection (any activity)
                    if (logCount <= 20 || logCount % 100 === 0) {
                        console.log(`Low audio activity: ${Math.round(average)}`);
                    }
                    consecutiveHighAudio = 0;
                } else {
                    consecutiveHighAudio = 0;
                }
                
                requestAnimationFrame(detectVCCCall);
            }
            
            detectVCCCall();
            console.log('VCC audio monitoring started successfully');
        }

        // Enhanced Quick Notes to auto-reset timer
        function addQuickNote(noteText) {
            const notesTextarea = document.getElementById('notes');
            const currentNotes = notesTextarea.value.trim();
            
            if (currentNotes) {
                notesTextarea.value = currentNotes + ' ' + noteText;
            } else {
                notesTextarea.value = noteText;
            }
            
            // Auto-reset dead air timer (indicates speaking)
            if (AppState.timerRunning) {
                resetTimer();
            }
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Update tag recommendations after adding note
            analyzeNotesForTags();
            
            // Visual feedback
            showNotification(`Added: ${noteText}`, 'success', 2000);
            
            // Scroll to end of textarea
            notesTextarea.scrollTop = notesTextarea.scrollHeight;
            notesTextarea.setSelectionRange(notesTextarea.value.length, notesTextarea.value.length);
        }

        // Utility functions
        function showNotification(message, type = 'success', duration = 3000) {
            // Remove existing notifications
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.setAttribute('role', 'alert');
            notification.setAttribute('aria-live', 'polite');
            
            document.body.appendChild(notification);
            
            // Trigger animation
            setTimeout(() => notification.classList.add('show'), 100);
            
            // Auto remove
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }

        function addButtonFeedback(button, type = 'success') {
            const originalClass = button.className;
            button.classList.add(`${type}-feedback`);
            setTimeout(() => {
                button.className = originalClass;
            }, 200);
        }

        function validateInput(value, type = 'text') {
            if (type === 'storeNumber') {
                return /^\d+$/.test(value) || value === '';
            }
            return true;
        }

        // Enhanced theme management
        function toggleTheme() {
            try {
                const body = document.body;
                const button = document.getElementById('theme-toggle-btn');
                
                body.classList.toggle('light-mode');
                body.classList.toggle('dark-mode');
                const isDark = body.classList.contains('dark-mode');
                
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                updateThemeIcon(isDark);
                
                // Update button aria-label
                button.setAttribute('aria-label', 
                    isDark ? 'Switch to light mode' : 'Switch to dark mode'
                );
                
                showNotification(`Switched to ${isDark ? 'dark' : 'light'} mode`, 'success', 1500);
            } catch (error) {
                console.error('Theme toggle failed:', error);
                showNotification('Failed to toggle theme', 'error');
            }
        }

        function updateThemeIcon(isDark) {
            const icon = document.getElementById('theme-toggle-icon');
            if (icon) {
                if (isDark) {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                } else {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                }
            }
        }

        // Enhanced history management with better error handling
        function saveNotesHistory() {
            try {
                const formData = getFormData();
                
                if (!hasValidData(formData)) {
                    return false;
                }

                const noteEntry = {
                    ...formData,
                    timestamp: Date.now(),
                    id: generateId()
                };

                let history = getNotesHistory();
                history = cleanOldEntries(history);
                
                // Prevent duplicate entries
                const isDuplicate = history.some(entry => 
                    entry.techName === formData.techName &&
                    entry.storeNumber === formData.storeNumber &&
                    entry.workOrder === formData.workOrder &&
                    Math.abs(entry.timestamp - noteEntry.timestamp) < 60000 // Within 1 minute
                );
                
                if (!isDuplicate) {
                    history.push(noteEntry);
                    localStorage.setItem('notesHistory', JSON.stringify(history));
                    updateHistoryDropdown();
                }
                
                return true;
            } catch (error) {
                console.error('Failed to save notes history:', error);
                showNotification('Failed to save to history', 'error');
                return false;
            }
        }

        function getFormData() {
            return {
                techName: document.getElementById('tech-name').value.trim(),
                storeNumber: document.getElementById('store-number').value.trim(),
                workOrder: document.getElementById('work-order').value.trim(),
                notes: document.getElementById('notes').value.trim()
            };
        }

        function hasValidData(data) {
            return Object.values(data).some(value => value.length > 0);
        }

        function getNotesHistory() {
            try {
                return JSON.parse(localStorage.getItem('notesHistory') || '[]');
            } catch (error) {
                console.error('Failed to parse notes history:', error);
                return [];
            }
        }

        function cleanOldEntries(history) {
            const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
            return history.filter(entry => Date.now() - entry.timestamp <= sevenDaysInMs);
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function updateHistoryDropdown() {
            try {
                const history = getNotesHistory();
                const historySelect = document.getElementById('history');
                
                if (!historySelect) return;
                
                historySelect.innerHTML = '<option value="">-- Select Previous Notes --</option>';
                
                // Sort by timestamp (newest first)
                const sortedHistory = history.sort((a, b) => b.timestamp - a.timestamp);
                
                sortedHistory.forEach((entry) => {
                    const date = new Date(entry.timestamp).toLocaleString();
                    // Truncate techName and storeNumber for better readability
                    let techName = entry.techName || 'No Name';
                    let storeNumber = entry.storeNumber || 'N/A';
                    if (techName.length > 18) techName = techName.substring(0, 15) + '...';
                    if (storeNumber.length > 10) storeNumber = storeNumber.substring(0, 10) + '...';
                    const label = `${date} - ${techName} (Store: ${storeNumber})`;
                    const option = document.createElement('option');
                    option.value = entry.id;
                    option.textContent = label;
                    historySelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to update history dropdown:', error);
            }
        }

        function restoreNotes() {
            try {
                const historySelect = document.getElementById('history');
                const selectedId = historySelect.value;
                if (!selectedId) return;

                const history = getNotesHistory();
                const entry = history.find(e => e.id === selectedId);
                
                if (entry) {
                    document.getElementById('tech-name').value = entry.techName || '';
                    document.getElementById('store-number').value = entry.storeNumber || '';
                    document.getElementById('work-order').value = entry.workOrder || '';
                    document.getElementById('notes').value = entry.notes || '';
                    
                    showNotification('Notes restored successfully', 'success', 2000);
                    
                    // Auto-save after restore
                    scheduleAutoSave();
                }
            } catch (error) {
                console.error('Failed to restore notes:', error);
                showNotification('Failed to restore notes', 'error');
            }
        }

        // Helper for DAE notes overwrite confirmation
        function shouldOverwriteDAENotes(notesBox) {
            // Returns true if it's safe to overwrite, or user confirms overwrite
            if (!notesBox.dataset.userEdited || notesBox.dataset.userEdited === 'false' || !notesBox.value.trim()) {
                return true;
            }
            return confirm('This will overwrite your current DAE notes. Continue?');
        }

        // DAE Templates managed in JavaScript for maintainability
        const DAE_TEMPLATES = {
            "Help Desk Post": `Store # 
EMS - 
WO# - 
Issue - 
What have you done? 
Wiki Link Used - 
Any screenshots of issue.:`,

            "Condenser and Compressor Staging Changes": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:`,

            "Changes to Rack Suction Settings": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:`,

            "Reporting Issues with IoT": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed error description:
Screenshots of the error in IoT as well as any supporting screenshots from the EMS system. Paste them into a Word doc and attach it to the work order when you create it.:`,

            "Setting MAC Addresses": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
New device type and position (For example, Novar ES1 on rack LTB or Emerson E2E on HVAC):
MAC address of the new device (must be 12 characters):
Old MAC address:`,

            "Controller COMM Loss": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
Is the ethernet cable plugged into the device, yes or no?:
Controller type (Novar EP2, Emerson E2E, Danfoss AK255 etc.):
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Has the controller been power cycled, yes or no?:
Is the controller functioning normally per the technician? If not, please provide details.: 
MAC address (must be 12 characters):
The switch and Port controller goes to (if tech can provide):`,

            "Changing Board Points": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
Current module address and point number.:
New module address and point number.:`,

            "Carel BOSS Support": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
Detailed description of technician request OR
If an alarm, include a screenshot of the alarm in IoT.:`,

            "Novar Download Failures": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Type of download needed (version, main, comm, etc.):
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Description of controller behavior or error messages received. Paste screenshots of error messages into a Word document and attach it to the work order as you create it.:`,

            "Danfoss Downloads": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Description of what prompted the download request (Controller change out, controller software failure, etc.):
MAC address (must be 12 characters):`,

            "Manager Escalations": `Name of the manager or team lead authorizing the escalation:
Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed description of the issue:
What actions Contact Center agents have taken so far:
Any supporting screenshots of EMS systems or other documentation. Paste screenshots of error messages into a Word document and attach it to the work order as you create it.:`,

            "Program Change Request": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:
A screenshot of the module in the EMS system.:`,

            "RTU Fans Mode": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
What RTU fan(s) the technician has requested to turn off and the reason for the request.:`,

            "Parameter Deviation": `Name of the manager or team lead authorizing the escalation:
Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed description of request:
Current setpoint and requested setpoint:
Screenshots of setpoint in EMS system and of the Parameter Cutsheet.:`,

            "Swap Work Order": `Swap Workorder Notes Show: (Enter the notes from the email).
Please email acserv@wal-mart.com when service is complete. Please provide notes regarding work done along with on/off site dates and times. You may also contact Alarm Central at 479-273-4600, options 1 and 4 between the hours of 7AM-7PM CST Mon-Fri:`,

            "Mastermind Work Order": `Mastermind Report Notes Show: (Enter the notes from the work order attachment that is in all caps).
Please email acserv@wal-mart.com when service is complete. Please provide notes regarding work done along with on/off site dates and times. You may also contact Alarm Central at 479-273-4600, options 1 and 4 between the hours of 7AM-7PM CST Mon-Fri:`
        };
        
                // Quick Notes functionality
        function addQuickNote(noteText) {
            const notesTextarea = document.getElementById('notes');
            const currentNotes = notesTextarea.value.trim();
            
            if (currentNotes) {
                notesTextarea.value = currentNotes + ' ' + noteText;
            } else {
                notesTextarea.value = noteText;
            }
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Visual feedback
            showNotification(`Added: ${noteText}`, 'success', 2000);
            
            // Scroll to end of textarea
            notesTextarea.scrollTop = notesTextarea.scrollHeight;
            notesTextarea.setSelectionRange(notesTextarea.value.length, notesTextarea.value.length);
        }

        function addQuickNoteWithInput(prefix, prompt) {
            const userInput = window.prompt(prompt);
            if (userInput !== null && userInput.trim() !== '') {
                addQuickNote(prefix + userInput.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addForcedNote() {
            const parameter = window.prompt('What did you force?\n\nExamples:\n‚Ä¢ Suct PSI to 30\n‚Ä¢ OAT to 68 degrees\n‚Ä¢ Discharge temp to 105\n‚Ä¢ Fan speed to 75%');
            if (parameter !== null && parameter.trim() !== '') {
                addQuickNote('Forced ' + parameter.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addForcedOffNote() {
            const notesContent = document.getElementById('notes').value;
            const daeContent = document.getElementById('dropdown-notes').value;
            const combinedContent = notesContent + ' ' + daeContent;
            
            // Look for previously forced items in the notes
            const forcedOnRegex = /Forced (?:on )?([^.]+)\./gi;
            const matches = [];
            let match;
            
            while ((match = forcedOnRegex.exec(combinedContent)) !== null) {
                const item = match[1].trim();
                // Skip if it's already been forced off
                if (!combinedContent.toLowerCase().includes('forced off ' + item.toLowerCase())) {
                    matches.push(item);
                }
            }
            
            if (matches.length > 0) {
                // Use the most recent forced item
                const lastForcedItem = matches[matches.length - 1];
                addQuickNote('Forced off ' + lastForcedItem + '.');
                showNotification(`Auto-detected: ${lastForcedItem}`, 'success', 2000);
            } else {
                // No forced items found, prompt for input
                const item = window.prompt('What did you force off?\n\nExamples:\n‚Ä¢ Bypass Valve\n‚Ä¢ Compressor 2\n‚Ä¢ Fan speed\n‚Ä¢ lights');
                if (item !== null && item.trim() !== '') {
                    addQuickNote('Forced off ' + item.trim() + '.');
                }
            }
        }

        function addSetpointNote() {
            const coolTemp = window.prompt('Enter cooling setpoint (¬∞F):\n\nExample: 72');
            if (coolTemp === null || coolTemp.trim() === '') return;
            
            const heatTemp = window.prompt('Enter heating setpoint (¬∞F):\n\nExample: 68');
            if (heatTemp === null || heatTemp.trim() === '') return;
            
            const unit = window.prompt('Enter unit/RTU:\n\nExamples:\n‚Ä¢ RTU 1\n‚Ä¢ RTU 2\n‚Ä¢ HVAC Unit A\n‚Ä¢ Unit 3');
            if (unit === null || unit.trim() === '') return;
            
            const note = `Changed setpoint to ${coolTemp.trim()}/${heatTemp.trim()} for ${unit.trim()}.`;
            addQuickNote(note);
        }

        function addTestNote() {
            const component = window.prompt('What did you test?\n\nExamples:\n‚Ä¢ controller functionality\n‚Ä¢ sensor readings\n‚Ä¢ valve operation\n‚Ä¢ communication');
            if (component !== null && component.trim() !== '') {
                addQuickNote('Tested ' + component.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addMonitorNote() {
            const instruction = window.prompt('Monitor what?\n\nExamples:\n‚Ä¢ temperatures for 30 minutes\n‚Ä¢ system and call back if issues persist\n‚Ä¢ alarms overnight\n‚Ä¢ pressures during peak hours');
            if (instruction !== null && instruction.trim() !== '') {
                addQuickNote('Advised to monitor ' + instruction.trim() + '.');
            }
        }

        function showContactOptions() {
            const contacts = [
                'Docfit',
                'Service Channel', 
                'Copeland',
                'Sporlan',
                'Other'
            ];
            
            let message = 'Select who to contact:\n\n';
            contacts.forEach((contact, index) => {
                message += `${index + 1}. ${contact}\n`;
            });
            
            const choice = window.prompt(message + '\nEnter number (1-5):');
            
            if (choice !== null && choice.trim() !== '') {
                const choiceNum = parseInt(choice.trim());
                if (choiceNum >= 1 && choiceNum <= 4) {
                    addQuickNote('Advised tech to contact ' + contacts[choiceNum - 1] + '.');
                    // Tag analysis is handled by addQuickNote
                } else if (choiceNum === 5) {
                    const customContact = window.prompt('Enter contact details:');
                    if (customContact !== null && customContact.trim() !== '') {
                        addQuickNote('Advised tech to contact ' + customContact.trim() + '.');
                        // Tag analysis is handled by addQuickNote
                    }
                }
            }
        }

        function addContactNote() {
            const contact = window.prompt('Contact who?\n\nExamples:\n‚Ä¢ HVAC vendor\n‚Ä¢ facilities management\n‚Ä¢ IT support\n‚Ä¢ local technician');
            if (contact !== null && contact.trim() !== '') {
                addQuickNote('Advised tech to contact ' + contact.trim() + '.');
            }
        }

        function addReplaceNote() {
            const component = window.prompt('Replace what?\n\nExamples:\n‚Ä¢ temperature sensor\n‚Ä¢ controller board\n‚Ä¢ communication cable\n‚Ä¢ valve actuator');
            if (component !== null && component.trim() !== '') {
                addQuickNote('Advised to replace ' + component.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addEscalateNote() {
            // Get the selected DAE option
            const daeSelect = document.getElementById('autofill');
            const selectedDAE = daeSelect.value;
            
            let daeText = 'Created DAE';
            if (selectedDAE && selectedDAE.trim() !== '') {
                daeText = 'Created ' + selectedDAE + ' DAE';
            }
            
            // Prompt for work order number
            const workOrder = window.prompt('Enter Work Order number:');
            
            if (workOrder !== null && workOrder.trim() !== '') {
                addQuickNote(daeText + '. Created WO: ' + workOrder.trim() + '.');
                // Tag analysis is handled by addQuickNote
            } else {
                // If no WO provided, just add the DAE part
                addQuickNote(daeText + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        // Enhanced notes updating with validation
        function updateNotes() {
            try {
                const selectedOption = document.getElementById('autofill').value;
                if (!selectedOption) return;

                const notesBox = document.getElementById('dropdown-notes');
                const selectedText = DAE_TEMPLATES[selectedOption] || '';

                if (!selectedText) {
                    showNotification('Template not found', 'error');
                    return;
                }

                // Use helper for overwrite confirmation
                if (shouldOverwriteDAENotes(notesBox)) {
                    notesBox.value = selectedText;
                    notesBox.dataset.userEdited = 'false';
                    showNotification('Template loaded', 'success', 1500);
                    
                    // Update tag recommendations after loading template
                    analyzeNotesForTags();
                }
            } catch (error) {
                console.error('Failed to update notes:', error);
                showNotification('Failed to load template', 'error');
            }
        }

        // Enhanced clipboard functionality
        async function copyToClipboard(event, elementId) {
            const button = event.target;
            try {
                const element = document.getElementById(elementId);
                
                if (!element) {
                    throw new Error('Element not found');
                }
                
                const textToCopy = element.value.trim();
                
                if (!textToCopy) {
                    showNotification('Nothing to copy', 'error');
                    return;
                }
                
                button.disabled = true;
                button.classList.add('loading');
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    // Fallback for older browsers
                    element.select();
                    document.execCommand('copy');
                }
                
                addButtonFeedback(button, 'success');
                showNotification('Copied to clipboard!', 'success');
                
            } catch (error) {
                console.error('Copy failed:', error);
                addButtonFeedback(button, 'error');
                showNotification('Failed to copy to clipboard', 'error');
            } finally {
                button.disabled = false;
                button.classList.remove('loading');
            }
        }

        async function copyAdditionalNotes(event) {
            try {
                const button = event.target;
                const formData = getFormData();
                
                const copiedText = [];
                if (formData.techName) copiedText.push(`Technician Name: ${formData.techName}`);
                if (formData.storeNumber) copiedText.push(`Store Number: ${formData.storeNumber}`);
                if (formData.workOrder) copiedText.push(`Work Order Number: ${formData.workOrder}`);
                if (formData.notes) copiedText.push(formData.notes);
                
                // Add selected tags if any
                const selectedTags = getSelectedTags();
                if (selectedTags.length > 0) {
                    copiedText.push(`Tags: ${selectedTags.join(', ')}`);
                }

                if (copiedText.length === 0) {
                    showNotification('No data to copy', 'error');
                    button.disabled = false;
                    button.classList.remove('loading');
                    return;
                }
                
                button.disabled = true;
                button.classList.add('loading');
                const success = saveNotesHistory();
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(copiedText.join('\n'));
                } else {
                    // Fallback
                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = copiedText.join('\n');
                    document.body.appendChild(tempTextarea);
                    tempTextarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextarea);
                }
                
                addButtonFeedback(button, 'success');
                const tagInfo = selectedTags.length > 0 ? ` (${selectedTags.length} tags included)` : '';
                showNotification(
                    success ? `Copied and saved to history!${tagInfo}` : `Copied successfully!${tagInfo}`, 
                    'success'
                );
                
            } catch (error) {
                console.error('Copy failed:', error);
                addButtonFeedback(event.target, 'error');
                showNotification('Failed to copy', 'error');
            } finally {
                const button = event.target;
                button.disabled = false;
                button.classList.remove('loading');
            }
        }

        // Enhanced form management
        function clearFormFields() {
            try {
                const fields = ['tech-name', 'store-number', 'work-order', 'notes', 'dropdown-notes'];
                fields.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.value = '';
                });
                
                const dropdownNotes = document.getElementById('dropdown-notes');
                if (dropdownNotes) dropdownNotes.dataset.userEdited = 'false';
                
                const selects = ['autofill', 'history'];
                selects.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.selectedIndex = 0;
                        element.value = '';
                    }
                });
                
                // Clear selected tags
                AppState.selectedTags.clear();
                displayRecommendedTags([]);
                
                showNotification('Form cleared', 'success', 1500);
                clearAutoSave();
                
            } catch (error) {
                console.error('Failed to clear form:', error);
                showNotification('Failed to clear form', 'error');
            }
        }

        function clearForm() {
            if (!confirm('This will clear all form data AND delete all saved history. Are you sure?')) {
                return;
            }
            
            try {
                clearFormFields();
                localStorage.removeItem('notesHistory');
                updateHistoryDropdown();
                showNotification('Everything cleared', 'success');
            } catch (error) {
                console.error('Failed to clear everything:', error);
                showNotification('Failed to clear everything', 'error');
            }
        }

        // Auto-save functionality
        function scheduleAutoSave() {
            clearTimeout(AppState.autoSaveTimer);
            AppState.autoSaveTimer = setTimeout(() => {
                const currentData = JSON.stringify(getFormData());
                if (currentData !== AppState.lastSavedData && hasValidData(getFormData())) {
                    saveNotesHistory();
                    AppState.lastSavedData = currentData;
                }
            }, 30000); // Auto-save after 30 seconds of inactivity
        }

        function clearAutoSave() {
            clearTimeout(AppState.autoSaveTimer);
            AppState.lastSavedData = null;
        }

        // Enhanced input validation
        function setupInputValidation() {
            const storeNumberInput = document.getElementById('store-number');
            if (storeNumberInput) {
                storeNumberInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    if (value && !/^\d+$/.test(value)) {
                        // Optionally, you can set a custom validity message here
                        // e.target.setCustomValidity('Please enter only numbers.');
                    } else {
                        e.target.setCustomValidity('');
                    }
                });
            }
            // Add auto-save only to specific text inputs and textareas (not selects)
            const formInputs = [
                document.getElementById('tech-name'),
                document.getElementById('store-number'),
                document.getElementById('work-order'),
                document.getElementById('notes'),
                document.getElementById('dropdown-notes')
            ].filter(Boolean);
            formInputs.forEach(input => {
                input.addEventListener('input', function() {
                    scheduleAutoSave();
                    // Analyze notes for tag recommendations
                    if (this.id === 'notes' || this.id === 'dropdown-notes') {
                        analyzeNotesForTags();
                    }
                });
            });
        }

        // Keyboard navigation enhancements
        function setupKeyboardNavigation() {
            // Theme toggle with keyboard
            document.addEventListener('keydown', function(e) {
                // Only trigger if not typing in an input field
                const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT';
                
                if (!isTyping) {
                    if (e.key === ' ' || e.key === 'Spacebar') {
                        e.preventDefault();
                        if (!AppState.timerRunning) {
                            startTimer();
                        }
                    }
                    
                    if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        resetTimer();
                    }
                    
                    if (e.key === 'p' || e.key === 'P') {
                        e.preventDefault();
                        pauseTimer();
                    }
                    
                    if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        resetCallDetection();
                    }
                }
                
                if (e.key === 'F2') {
                    e.preventDefault();
                    toggleTheme();
                }
                
                // Quick copy with Ctrl+Shift+C
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    copyAdditionalNotes();
                }
            });
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Set theme from localStorage
                const savedTheme = localStorage.getItem('theme');
                const isDark = savedTheme === 'dark';
                
                document.body.classList.remove('light-mode', 'dark-mode');
                document.body.classList.add(isDark ? 'dark-mode' : 'light-mode');
                updateThemeIcon(isDark);
                
                // Update theme button aria-label
                const themeButton = document.getElementById('theme-toggle-btn');
                if (themeButton) {
                    themeButton.setAttribute('aria-label', 
                        isDark ? 'Switch to light mode' : 'Switch to dark mode'
                    );
                }

                // Update history dropdown
                updateHistoryDropdown();

                // Setup enhanced functionality
                setupInputValidation();
                setupKeyboardNavigation();

                // Track user edits on dropdown-notes
                const dropdownNotes = document.getElementById('dropdown-notes');
                if (dropdownNotes) {
                    dropdownNotes.addEventListener('input', function() {
                        this.dataset.userEdited = 'true';
                    });
                }

                // Initialize auto-save state
                AppState.lastSavedData = JSON.stringify(getFormData());
                
                // Initialize microphone for dead air detection
                initializeMicrophone();
                
                // Initialize VCC integration
                initializeVCCIntegration();
                
                // Load saved infractions and update display
                loadTotalInfractions();
                updateInfractionDisplay();
                
                console.log('QA Checklist App initialized successfully');
                
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('App initialization failed', 'error');
            }
        });

        // Add notification container for accessibility
        document.addEventListener('DOMContentLoaded', function() {
            const notificationContainer = document.createElement('div');
            notificationContainer.setAttribute('aria-live', 'polite');
            notificationContainer.setAttribute('aria-atomic', 'true');
            notificationContainer.className = 'sr-only';
            notificationContainer.id = 'notification-announcer';
            document.body.appendChild(notificationContainer);
        });
    </script>
