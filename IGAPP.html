<!DOCTYPE html>
<!-- Version: 1.0.4 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Walmart Digital Assets QA Checklist and Notes Application">
    <title>Walmart Digital Assets - QA Checklist</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }

        body.light-mode {
            background-color: #ffffff;
            color: #000000;
        }

        body.dark-mode {
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .form-container {
            max-width: 1200px;
            width: 90%;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            transition: background-color 0.3s, border-color 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        @media (max-width: 768px) {
            .form-container {
                width: 95%;
                margin: 10px auto;
                padding: 15px;
                gap: 15px;
            }
            .form-section, .qa-container {
                min-width: 100%;
            }
        }

        body.light-mode .form-container {
            background: #f9f9f9;
            border-color: #ccc;
        }

        body.dark-mode .form-container {
            background: #2c2c2c;
            border-color: #555;
        }

        .form-section {
            flex: 2;
            min-width: 400px;
            order: 2;
        }

        .qa-container {
            flex: 1;
            min-width: 300px;
            order: 1;
        }        .qa-container h4 {
            margin: 15px 0 8px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            border-bottom: 1px solid #ddd;
            padding-bottom: 4px;
        }

        body.dark-mode .qa-container h4 {
            color: #ccc;
            border-bottom-color: #555;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .quick-note-btn {
            padding: 6px 10px;
            font-size: 12px;
            min-height: 28px;
            margin: 0;
            border-radius: 4px;
            flex: 0 0 auto;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .quick-note-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .success-quick {
            background-color: #28a745 !important;
            color: white !important;
        }

        .success-quick:hover {
            background-color: #218838 !important;
        }

        .error-quick {
            background-color: #dc3545 !important;
            color: white !important;
        }

        .error-quick:hover {
            background-color: #c82333 !important;
        }        textarea, input, select {
            width: 100%;
            margin-top: 10px;
            padding: 5px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body.light-mode textarea,
        body.light-mode input,
        body.light-mode select {
            background-color: #ffffff;
            color: #000000;
            border: 1px solid #ccc;
        }

        body.dark-mode textarea,
        body.dark-mode input,
        body.dark-mode select {
            background-color: #333;
            color: #ffffff;
            border: 1px solid #666;
        }

        textarea {
            height: 70px;
        }

        button {
            margin-top: 10px;
            margin-right: 10px;
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            min-height: 36px;
        }

        button:focus {
            outline: 2px solid #007bff;
            outline-offset: 2px;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .success-feedback {
            background-color: #28a745 !important;
            transform: scale(0.98);
        }

        .error-feedback {
            background-color: #dc3545 !important;
            transform: scale(0.98);
        }

        body.light-mode button {
            background-color: #007bff;
            color: #ffffff;
        }

        body.dark-mode button {
            background-color: #555;
            color: #ffffff;
        }

        body.light-mode button:hover {
            background-color: #0056b3;
        }

        body.dark-mode button:hover {
            background-color: #777;
        }

        .qa-container p {
            margin-bottom: 5px;
        }



        .notification {
            position: fixed;
            top: 60px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        /* Override for container-based notifications */
        .notification-container .notification {
            position: relative !important;
            top: auto !important;
            right: auto !important;
            pointer-events: auto;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
            opacity: 0;
            margin-bottom: 0;
            width: 100%;
            background: var(--bg-color, #fff);
            border: 1px solid var(--border-color, #ddd);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 14px;
            min-height: 40px;
            display: flex;
            align-items: center;
            color: #333;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background-color: #28a745;
        }

        .notification.error {
            background-color: #dc3545;
        }

        .notification.info {
            background-color: #17a2b8;
        }

        /* Container notification colors */
        .notification-container .notification.success {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
            color: #155724 !important;
        }

        .notification-container .notification.error {
            background-color: #f8d7da !important;
            border-color: #f5c6cb !important;
            color: #721c24 !important;
        }

        .notification-container .notification.info {
            background-color: #d1ecf1 !important;
            border-color: #bee5eb !important;
            color: #0c5460 !important;
        }

        .loading {
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .danger-button {
            background-color: #dc3545 !important;
        }

        .danger-button:hover {
            background-color: #c82333 !important;
        }

        .primary-button {
            background-color: #007bff !important;
            color: #ffffff !important;
        }

        .primary-button:hover {
            background-color: #0056b3 !important;
        }

        .success-button {
            background-color: #28a745 !important;
            color: #ffffff !important;
        }

        .success-button:hover {
            background-color: #218838 !important;
        }

        .theme-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            font-size: 1.5em;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .theme-toggle i {
            color: #ffffff;
        }

        /* Update button specific styling */
        #update-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        #update-btn:hover {
            background: linear-gradient(135deg, #218838 0%, #1fa8a2 100%);
        }

        /* Top update button specific styling (next to theme toggle) */
        #update-btn-top {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
        }

        #update-btn-top:hover {
            background: linear-gradient(135deg, #218838 0%, #1fa8a2 100%) !important;
        }

        /* Notes header with timer */
        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .notes-header h1 {
            margin: 0;
            flex: 1;
        }

        .notes-header .dead-air-timer {
            position: relative;
            top: 0;
            left: 0;
            margin-left: 15px;
        }

        /* Bottom-right update button */
        .update-button-bottom {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
        }

        .update-button-bottom:hover {
            background: linear-gradient(135deg, #218838 0%, #1fa8a2 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .update-button-bottom:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        /* Notification container for stacking */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            max-width: 350px;
        }

        .notification-container .notification {
            pointer-events: auto;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
            opacity: 0;
            margin-bottom: 0;
            position: relative;
            width: 100%;
        }

        .notification-container .notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        /* Dynamic update button (primary - copy method) */
        .dynamic-update-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #3742fa 0%, #2f3542 100%);
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            font-size: 16px;
            font-weight: 600;
            z-index: 1500;
            animation: pulse 2s infinite;
            cursor: pointer;
        }

        .dynamic-update-button:hover {
            background: linear-gradient(135deg, #2f3542 0%, #57606f 100%);
            transform: translate(-50%, -50%) scale(1.05);
        }

        /* Alternative download button */
        .dynamic-update-button-alt {
            position: fixed;
            top: calc(50% + 60px);
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            font-size: 14px;
            font-weight: 600;
            z-index: 1500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dynamic-update-button-alt:hover {
            background: linear-gradient(135deg, #ee5a24 0%, #c23616 100%);
            transform: translate(-50%, -50%) scale(1.05);
        }

        @keyframes pulse {
            0% { box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 6px 30px rgba(255,107,107,0.5); }
            100% { box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        }

        /* Update instructions */
        .update-instructions {
            position: fixed;
            top: calc(50% + 50px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 15px;
            z-index: 1400;
            backdrop-filter: blur(5px);
            font-size: 12px;
            text-align: center;
        }

        /* Update modal */
        .update-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .update-modal {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: left;
        }

        .update-modal h3 {
            margin: 0 0 20px 0;
            color: #28a745;
            text-align: center;
            font-size: 24px;
        }

        .update-steps ol {
            padding-left: 20px;
            line-height: 1.6;
        }

        .update-steps li {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .update-steps code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: #d63384;
        }

        .update-note {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 13px;
        }

        .update-modal-btn {
            display: block;
            margin: 20px auto 0;
            padding: 12px 30px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .update-modal-btn:hover {
            background: #218838;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .notes-header {
                flex-direction: column;
                align-items: stretch;
            }

            .notes-header .dead-air-timer {
                margin-left: 0;
                margin-top: 10px;
                align-self: flex-end;
            }

            .update-button-bottom {
                bottom: 10px;
                right: 10px;
                padding: 10px 16px;
                font-size: 12px;
            }

            .update-button-bottom span {
                display: none;
            }
        }

        .dead-air-timer {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            justify-content: center;
        }

        .dead-air-timer.warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            animation: pulse-warning 1s infinite;
        }

        .dead-air-timer.critical {
            background: linear-gradient(135deg, #dc3545 0%, #e74c3c 100%);
            animation: flash-critical 0.5s infinite;
        }

        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes flash-critical {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .timer-controls {
            display: flex;
            gap: 4px;
        }

        .timer-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .timer-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .mic-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #dc3545;
            transition: background 0.3s;
        }

        .mic-status.active {
            background: #28a745;
            animation: pulse-mic 2s infinite;
        }

        @keyframes pulse-mic {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        small {
            display: block;
            margin-top: 4px;
            font-size: 12px;
            opacity: 0.7;
        }

        .tag-recommendations {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        body.light-mode .tag-recommendations {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        body.dark-mode .tag-recommendations {
            background: #343a40;
            border-color: #495057;
        }

        .tag-recommendations h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        body.dark-mode .tag-recommendations h4 {
            color: #ccc;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 24px;
            align-items: center;
        }

        .tag-item {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            user-select: none;
        }

        .tag-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tag-item.high-confidence {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            font-weight: 500;
        }

        .tag-item.medium-confidence {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #212529;
            font-weight: 500;
        }

        .tag-item.low-confidence {
            background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%);
            color: white;
        }

        .tag-item.selected {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%) !important;
            color: white !important;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.3);
        }

        .tag-confidence-legend {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 8px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .tag-confidence-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tag-confidence-legend .legend-color {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }

        .legend-high { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }
        .legend-medium { background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%); }
        .legend-low { background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%); }

        .infraction-tracker {
            position: fixed;
            top: 106px;
            right: 10px;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .infraction-session, .infraction-total {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .infraction-session {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 4px;
        }

        .infraction-total {
            padding-top: 2px;
        }

        .infraction-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: background 0.2s;
            min-width: 20px;
        }

        .infraction-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .infraction-tracker.has-infractions {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse-infractions 2s infinite;
        }

        @keyframes pulse-infractions {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .update-button {
            position: fixed;
            top: 150px;
            right: 10px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            z-index: 1001;
            animation: pulse-update 2s infinite;
        }

        .update-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        @keyframes pulse-update {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
    </style>
</head>
<body class="light-mode">
    
    <div class="infraction-tracker" id="infraction-tracker">
        <div class="infraction-session">
            <span>Session: </span>
            <span id="session-count">0</span>
            <button class="infraction-btn" onclick="clearLastInfraction()" title="Clear Last Infraction">‚ùå</button>
        </div>
        <div class="infraction-total">
            <span>Total: </span>
            <span id="total-count">0</span>
            <button class="infraction-btn" onclick="clearTotalInfractions()" title="Clear Total Count">üóëÔ∏è</button>
        </div>
    </div>
    
    <button class="theme-toggle" aria-label="Toggle between light and dark mode" onclick="toggleTheme()" id="theme-toggle-btn" tabindex="0">
        <i class="fas fa-sun" id="theme-toggle-icon" aria-hidden="true"></i>
    </button>
    
    <button class="update-button-bottom" aria-label="Check for Updates" onclick="checkForUpdates()" id="update-btn" tabindex="0">
        <i class="fas fa-sync-alt" id="update-icon" aria-hidden="true"></i>
        <span>Check for Updates</span>
    </button>
    
    <button class="theme-toggle" aria-label="Check for Updates" onclick="checkForUpdates()" id="update-btn-top" tabindex="0" style="right: 80px;">
        <i class="fas fa-sync-alt" id="update-icon-top" aria-hidden="true"></i>
    </button>
    </button>

    <div class="form-container">
        <!-- Quick Notes Buttons on the Left -->
        <div class="qa-container">
            <h3>Quick Notes</h3>
            
            <h4>System Login</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Logged into Novar.')" class="quick-note-btn" title="Novar Login">Novar</button>
                <button onclick="addQuickNote('Logged into Opus Arch.')" class="quick-note-btn" title="Opus Arch Login">Opus Arch</button>
                <button onclick="addQuickNote('Logged into Opus Mag.')" class="quick-note-btn" title="Opus Mag Login">Opus Mag</button>
                <button onclick="addQuickNote('Logged into CPC.')" class="quick-note-btn" title="CPC Login">CPC</button>
                <button onclick="addQuickNote('Logged into Danfoss AKA65.')" class="quick-note-btn" title="Danfoss AKA65 Login">AKA65</button>
                <button onclick="addQuickNote('Logged into Danfoss Storeview.')" class="quick-note-btn" title="Danfoss Storeview Login">Storeview</button>
            </div>

            <h4>Diagnostics</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Checked comms.')" class="quick-note-btn" title="Communications Check">Comms ‚úì</button>
                <button onclick="addQuickNote('Checked comms. Still in comm loss.')" class="quick-note-btn" title="Communications Loss">Comms ‚úó</button>
                <button onclick="addQuickNote('Checked temps.')" class="quick-note-btn" title="Temperature Check">Temps</button>
                <button onclick="addQuickNote('Checked alarms.')" class="quick-note-btn" title="Alarm Check">Alarms</button>
                <button onclick="addQuickNote('Checked clocks.')" class="quick-note-btn" title="Clock Check">Clocks</button>
                <button onclick="addQuickNote('Pinged controller.')" class="quick-note-btn" title="Ping Test">Ping</button>
                <button onclick="addTestNote()" class="quick-note-btn" title="Test Component">Test</button>
            </div>

            <h4>Ping Results</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Receiving good ping.')" class="quick-note-btn success-quick" title="Successful Ping">Good Ping</button>
                <button onclick="addQuickNote('Ping timedout.')" class="quick-note-btn error-quick" title="Failed Ping">Ping Timeout</button>
            </div>

            <h4>Actions</h4>
            <div class="button-group">
                <button onclick="addQuickNoteWithInput('Forced defrost on ', 'Enter rack/unit:')" class="quick-note-btn" title="Force Defrost">Defrost</button>
                <button onclick="addQuickNote('Terminated Defrost.')" class="quick-note-btn" title="Stop Defrost">Stop Defrost</button>
                <button onclick="addQuickNoteWithInput('Forced on ', 'Enter equipment:')" class="quick-note-btn" title="Force Equipment On">Force On</button>
                <button onclick="addForcedNote()" class="quick-note-btn" title="Force Parameter">Forced</button>
                <button onclick="addForcedOffNote()" class="quick-note-btn" title="Force Off Previously Forced Item">Forced Off</button>
                <button onclick="addQuickNote('Forced on lights.')" class="quick-note-btn" title="Force Lights On">Lights On</button>
                <button onclick="addSetpointNote()" class="quick-note-btn" title="Change Temperature Setpoint">Setpoint</button>
                <button onclick="addQuickNote('Reset clocks.')" class="quick-note-btn" title="Reset System Clocks">Reset Clocks</button>
            </div>

            <h4>Downloads</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Performed Version Download.')" class="quick-note-btn" title="Version Download">Version</button>
                <button onclick="addQuickNote('Performed Load Change Download.')" class="quick-note-btn" title="Load Change Download">Load Change</button>
                <button onclick="addQuickNote('Performed Comms and Load Change Download.')" class="quick-note-btn" title="Comms + Load Change">Comms+LC</button>
                <button onclick="addQuickNote('Performed Main and Load Change Download.')" class="quick-note-btn" title="Main + Load Change">Main+LC</button>
                <button onclick="addQuickNote('Performed Main, Comms, and Load Change Download.')" class="quick-note-btn" title="Full Download">Full DL</button>
            </div>

            <h4>Call Status</h4>
            <div class="button-group">
                <button onclick="addQuickNote('All good.')" class="quick-note-btn success-quick" title="Everything Working">All Good</button>
                <button onclick="addQuickNote('No good.')" class="quick-note-btn error-quick" title="Issue Persists">No Good</button>
                <button onclick="addQuickNote('Tech will troubleshoot.')" class="quick-note-btn" title="Tech Troubleshooting">Tech T/S</button>
                <button onclick="addQuickNote('Tech no longer needed assistance.')" class="quick-note-btn success-quick" title="Call Complete">Call Done</button>
                <button onclick="addEscalateNote()" class="quick-note-btn" title="Escalate with DAE and WO">Escalate</button>
            </div>

            <h4>Special Cases</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Call dropped.')" class="quick-note-btn error-quick" title="Call Disconnected">Call Dropped</button>
                <button onclick="addQuickNote('Tech called for a suppression. Adv tech of NSRM email.')" class="quick-note-btn" title="Suppression Request">NSRM</button>
                <button onclick="addQuickNote('Adv tech to power cycle controller.')" class="quick-note-btn" title="Power Cycle Recommendation">Power Cycle</button>
            </div>

            <h4>Recommendations</h4>
            <div class="button-group">
                <button onclick="addQuickNote('Advised to monitor and call back if issues persist.')" class="quick-note-btn" title="Monitor Instruction">Monitor</button>
                <button onclick="showContactOptions()" class="quick-note-btn" title="Contact Instruction">Contact</button>
                <button onclick="addReplaceNote()" class="quick-note-btn" title="Replace Instruction">Replace</button>
            </div>
        </div>

        <!-- Form Fields on the Right -->
        <div class="form-section">
            <div class="notes-header">
                <h1>Notes</h1>
                <div class="dead-air-timer" id="dead-air-timer">
                    <div class="mic-status" id="mic-status" title="Microphone status"></div>
                    <span id="timer-display">00:00</span>
                    <div class="timer-controls">
                        <button class="timer-btn" onclick="resetTimer()" title="I Spoke / Reset">üó£</button>
                        <button class="timer-btn" onclick="toggleAutoStart()" title="Toggle Auto-Start">ü§ñ</button>
                    </div>
                </div>
            </div>

            <label for="history">View Previous Notes:</label>
            <select id="history" onchange="restoreNotes()" aria-describedby="history-help">
                <option value="">-- Select Previous Notes --</option>
            </select>
            <small id="history-help" class="sr-only">Select from previously saved notes from the last 7 days</small>

            <label for="tech-name">Technician Name:</label>
            <input type="text" id="tech-name" placeholder="Enter technician name" aria-required="false" autocomplete="name">

            <label for="store-number">Store Number:</label>
            <input type="number" id="store-number" placeholder="Enter store number" aria-required="false" inputmode="numeric">

            <label for="work-order">Work Order Number:</label>
            <input type="text" id="work-order" placeholder="Enter work order number" aria-required="false">

            <label for="autofill">Select a DAE:</label>
            <select id="autofill" onchange="updateNotes()" aria-describedby="autofill-help">
                <option value="">-- Select an Option --</option>
                <option value="Help Desk Post">Help Desk Post</option>
                <option value="Condenser and Compressor Staging Changes">Condenser and Compressor Staging Changes</option>
                <option value="Changes to Rack Suction Settings">Changes to Rack Suction Settings</option>
                <option value="Reporting Issues with IoT">Reporting Issues with IoT</option>
                <option value="Setting MAC Addresses">Setting MAC Addresses for Controller Replacements</option>
                <option value="Controller COMM Loss">Controller COMM Loss Related to Network & Cabling</option>
                <option value="Changing Board Points">Changing Board Points in Danfoss or CPC</option>
                <option value="Carel BOSS Support">Calls, alarms, or emails related to Carel BOSS controllers</option>
                <option value="Novar Download Failures">Novar Downloads that Failed After Second Attempt</option>
                <option value="Danfoss Downloads">Downloads for any Danfoss controller</option>
                <option value="Manager Escalations">Manager Escalations</option>
                <option value="Program Change Request">Program Change Request</option>
                <option value="RTU Fans Mode">Taking RTU Fans Out Of Continuous Mode</option>
                <option value="Parameter Deviation">Parameter Deviation Request</option>
                <option value="Swap Work Order">Swap Work Order</option>
                <option value="Mastermind Work Order">Mastermind Work Order</option>
            </select>

            <label for="dropdown-notes">DAE:</label>
            <textarea id="dropdown-notes" placeholder="Selecting a dropdown will load a template here. If this box is not empty, you will be asked to confirm before overwriting." aria-describedby="dae-help"></textarea>
            <small id="dae-help" class="sr-only">Template text for Digital Asset Expert procedures</small>
            <small id="autofill-help" class="sr-only">Selecting an option will populate the DAE textarea with template text</small>
            <button onclick="copyToClipboard(event, 'dropdown-notes')" aria-describedby="copy-dae-help" class="primary-button">Copy DAE</button>
            <small id="copy-dae-help" class="sr-only">Copy DAE template text to clipboard</small>

            <label for="notes">Your Call Notes:</label>
            <textarea id="notes" placeholder="Enter your call notes here..." aria-describedby="notes-help"></textarea>
            <small id="notes-help" class="sr-only">Enter additional notes about the call. This will be combined with technician information when copied.</small>
            <button onclick="copyAdditionalNotes(event)" aria-describedby="copy-notes-help" class="success-button">Copy Notes</button>
            <small id="copy-notes-help" class="sr-only">Copy all form data including technician info and notes to clipboard</small>
            <button onclick="clearFormFields()" aria-describedby="clear-form-help" class="primary-button">Clear Form</button>
            <small id="clear-form-help" class="sr-only">Clear all form fields but keep history</small>
            <button onclick="clearForm()" aria-describedby="clear-all-help" class="danger-button">Clear Everything</button>
            <small id="clear-all-help" class="sr-only">Clear all form fields and delete all saved history</small>
            
            <!-- Temporary Export Feature -->
            <button onclick="exportNotesData()" aria-describedby="export-help" class="primary-button" style="margin-top: 10px; background: #6f42c1;">üìä Export Notes Data</button>
            <small id="export-help" class="sr-only">Export your notes usage data for analysis and improvement</small>
            
            <div id="tag-recommendations" class="tag-recommendations">
                <h4>Recommended Tags</h4>
                <div id="recommended-tags" class="tag-list">
                    <small>Tags will appear here based on your notes content...</small>
                </div>
            </div>
        </div>
    </div>

<!-- Templates are now managed in JavaScript for maintainability -->

    <script>
        // Global state management
        const AppState = {
            autoSaveTimer: null,
            lastSavedData: null,
            deadAirTimer: null,
            deadAirSeconds: 0,
            timerRunning: false,
            micStream: null,
            speakerStream: null,
            micAudioContext: null,
            speakerAudioContext: null,
            micAnalyser: null,
            speakerAnalyser: null,
            micActive: false,
            callDetected: false,
            autoStartEnabled: true,
            loudSoundThreshold: 80, // Higher threshold for call detection (speakers)
            speechThreshold: 25,    // Lower threshold for voice detection (microphone)
            selectedTags: new Set(),
            sessionInfractions: 0,  // Resets each call
            totalInfractions: 0,    // Persists across calls
            deadAirThreshold: 30,   // Seconds before infraction
            currentVersion: '1.0.4', // Update this when you make changes
            githubRepo: 'shadow11001/IGAPP',
            githubToken: null, // Will be decoded from masked token
            autoUpdateEnabled: true,
            // Masked GitHub token (Base64 + simple XOR obfuscation)
            // Your encoded token is now configured
            maskedToken: 'TUNeQl9IdVpLXnUbG2toGRh4bHsaa1ITZ2hMa0dhYWIYdVtvR2saeRx5cEwTYGRsa2hrGh5NR01MT2caWXlMYmhde2tsa3NoHkNZXm54YB5pYxhtGGxpbx5cUEZN', // Your encoded token
        };

        // Tag analysis system
        const TAG_KEYWORDS = {
            'Call Dropped Mid Call': ['call dropped', 'dropped', 'disconnected', 'lost connection'],
            'Caller Couldn\'t Hear Me': ['couldn\'t hear me', 'can\'t hear me', 'audio issues', 'mic problems'],
            'Carel': ['carel', 'boss'],
            'Couldn\'t Hear Caller': ['couldn\'t hear', 'can\'t hear caller', 'audio problems', 'static'],
            'Comms': ['comm loss', 'communication loss', 'network', 'ethernet', 'comms', 'communication'],
            'CPC': ['cpc'],
            'DAE': ['dae', 'escalat', 'work order', 'wo'],
            'Danfoss AKA65': ['aka65', 'aka'],
            'Danfoss SVD': ['svd', 'storeview'],
            'Defrost': ['defrost', 'forced defrost', 'terminated defrost'],
            'Download': ['download', 'version download', 'load change download', 'main download', 'comms download', 'full dl', 'performed download'],
            'Duplicate': ['duplicate', 'already called', 'repeat'],
            'Electrician Request': ['electrician', 'electrical', 'power issue'],
            'EMS': ['ems', 'system'],
            'Equipment Request': ['equipment', 'replace', 'new'],
            'Fuel Request': ['fuel', 'generator fuel'],
            'HVAC': ['hvac', 'air conditioning', 'heating', 'rtu'],
            'Lighting': ['lights', 'lighting', 'forced on lights'],
            'Manager Escalation': ['manager', 'escalation', 'supervisor'],
            'Mobile Gen Staging': ['mobile gen', 'generator staging'],
            'Monitoring (Mobile Gen)': ['monitor', 'mobile gen'],
            'Monitoring (PMG)': ['monitor', 'pmg'],
            'New Module': ['new module', 'module'],
            'No Reply Needed': ['no reply', 'information only'],
            'Novar ESS': ['novar', 'ess'],
            'Opus Architect': ['opus arch', 'architect'],
            'Opus Magnum': ['opus mag', 'magnum'],
            'Other': ['other', 'misc', 'various'],
            'PMG Request': ['pmg'],
            'Point Change': ['point change', 'board point', 'changing board'],
            'Power Alerts Change Request': ['power alert', 'alert change'],
            'Power Cycle': ['power cycle', 'restart', 'reboot'],
            'Power Restoral Emails': ['power restoral', 'power restored'],
            'PPO': ['ppo'],
            'Project': ['project'],
            'Queue Cap': ['queue cap', 'capacity'],
            'Really Distant/Underwater': ['distant', 'underwater', 'poor connection', 'bad line'],
            'Refrigeration': ['refrigeration', 'rack', 'cooling', 'temps', 'temperature', 'defrost', 'forced defrost', 'terminated defrost'],
            'Refrigeration Tech Request': ['refrigeration tech', 'ref tech'],
            'Remodel': ['remodel', 'renovation'],
            'Reroute': ['reroute', 'redirect'],
            'Set Points': ['setpoint', 'set point', 'temperature setting'],
            'Site Emergency': ['emergency', 'urgent', 'critical'],
            'Sporlan': ['sporlan'],
            'Static': ['static', 'noise', 'interference'],
            'Suppression': ['suppression', 'nsrm'],
            'Test': ['test', 'testing', 'tested'],
            'Unplanned Power Outage': ['power outage', 'outage', 'power loss'],
            'Utility Notification': ['utility', 'notification'],
            'Sams': ['sams', 'sam\'s club']
        };

        function analyzeNotesForTags() {
            const notesContent = document.getElementById('notes').value.toLowerCase();
            const daeContent = document.getElementById('dropdown-notes').value.toLowerCase();
            const combinedContent = (notesContent + ' ' + daeContent).trim();
            
            if (!combinedContent) {
                displayRecommendedTags([]);
                return;
            }
            
            const tagScores = {};
            
            // Analyze content for tag keywords
            for (const [tag, keywords] of Object.entries(TAG_KEYWORDS)) {
                let score = 0;
                let matchCount = 0;
                
                keywords.forEach(keyword => {
                    const regex = new RegExp('\\b' + keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                    const matches = combinedContent.match(regex);
                    if (matches) {
                        matchCount += matches.length;
                        score += matches.length * (keyword.length > 3 ? 2 : 1); // Longer keywords get more weight
                    }
                });
                
                if (score > 0) {
                    tagScores[tag] = { score, matchCount };
                }
            }
            
            // Sort tags by score and determine confidence levels
            const sortedTags = Object.entries(tagScores)
                .sort(([,a], [,b]) => b.score - a.score)
                .slice(0, 8) // Show top 8 recommendations
                .map(([tag, data]) => {
                    let confidence = 'low';
                    if (data.score >= 4 || data.matchCount >= 3) confidence = 'high';
                    else if (data.score >= 2 || data.matchCount >= 2) confidence = 'medium';
                    
                    return { tag, confidence, score: data.score };
                });
            
            displayRecommendedTags(sortedTags);
        }

        function displayRecommendedTags(tags) {
            const tagContainer = document.getElementById('recommended-tags');
            
            if (tags.length === 0) {
                tagContainer.innerHTML = '<small>Tags will appear here based on your notes content...</small>';
                return;
            }
            
            const tagElements = tags.map(({ tag, confidence }) => {
                const isSelected = AppState.selectedTags.has(tag);
                return `<span class="tag-item ${confidence}-confidence ${isSelected ? 'selected' : ''}" 
                              onclick="toggleTag('${tag.replace(/'/g, '\\\'')}')" 
                              title="Click to select/deselect this tag">
                            ${tag}
                        </span>`;
            }).join('');
            
            const legend = `
                <div class="tag-confidence-legend">
                    <span><div class="legend-color legend-high"></div>High confidence</span>
                    <span><div class="legend-color legend-medium"></div>Medium confidence</span>
                    <span><div class="legend-color legend-low"></div>Low confidence</span>
                </div>
            `;
            
            tagContainer.innerHTML = tagElements + legend;
        }

        function toggleTag(tagName) {
            if (AppState.selectedTags.has(tagName)) {
                AppState.selectedTags.delete(tagName);
            } else {
                AppState.selectedTags.add(tagName);
            }
            
            // Update visual state
            const tagElements = document.querySelectorAll('.tag-item');
            tagElements.forEach(element => {
                if (element.textContent.trim() === tagName) {
                    element.classList.toggle('selected');
                }
            });
            
            // Show notification
            const action = AppState.selectedTags.has(tagName) ? 'Selected' : 'Deselected';
            showNotification(`${action} tag: ${tagName}`, 'success', 1500);
        }

        function getSelectedTags() {
            return Array.from(AppState.selectedTags);
        }

        // Dead Air Timer Functions
        function startTimer() {
            if (!AppState.timerRunning) {
                // Clear any existing timer first
                if (AppState.deadAirTimer) {
                    clearInterval(AppState.deadAirTimer);
                    AppState.deadAirTimer = null;
                }
                
                AppState.timerRunning = true;
                AppState.deadAirTimer = setInterval(updateTimer, 1000);
                showNotification('Dead air timer started', 'success', 1500);
            }
        }

        function pauseTimer() {
            AppState.timerRunning = false;
            if (AppState.deadAirTimer) {
                clearInterval(AppState.deadAirTimer);
                AppState.deadAirTimer = null;
            }
            showNotification('Timer paused', 'success', 1500);
        }

        function resetTimer() {
            AppState.deadAirSeconds = 0;
            updateTimerDisplay();
            updateTimerVisuals();
            showNotification('Timer reset - You spoke!', 'success', 1000);
        }

        function updateTimer() {
            if (AppState.timerRunning) {
                AppState.deadAirSeconds++;
                updateTimerDisplay();
                updateTimerVisuals();
                
                // Check for infraction at 30 seconds
                if (AppState.deadAirSeconds === AppState.deadAirThreshold) {
                    recordInfraction();
                }
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(AppState.deadAirSeconds / 60);
            const seconds = AppState.deadAirSeconds % 60;
            const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer-display').textContent = display;
        }

        function updateTimerVisuals() {
            const timer = document.getElementById('dead-air-timer');
            timer.classList.remove('warning', 'critical');
            
            if (AppState.deadAirSeconds >= 30) {
                timer.classList.add('critical');
            } else if (AppState.deadAirSeconds >= 25) {
                timer.classList.add('warning');
            }
        }

        // Microphone Detection (for voice detection only)
        async function initializeMicrophone() {
            try {
                console.log('Attempting to initialize microphone...');
                
                // Get microphone for voice detection
                AppState.micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                console.log('Microphone access granted');
                
                AppState.micAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                AppState.micAnalyser = AppState.micAudioContext.createAnalyser();
                const micSource = AppState.micAudioContext.createMediaStreamSource(AppState.micStream);
                micSource.connect(AppState.micAnalyser);
                
                AppState.micAnalyser.fftSize = 256;
                AppState.micAnalyser.smoothingTimeConstant = 0.8;
                
                console.log('Audio context created, starting voice detection...');
                startVoiceDetection();
                
                // Try to get speaker/system audio for call detection
                initializeSpeakerDetection();
                
            } catch (error) {
                console.error('Microphone initialization failed:', error);
                showNotification('Microphone access denied - Using manual controls only', 'error', 3000);
            }
        }

        async function initializeSpeakerDetection() {
            try {
                // Try to capture system audio (speakers) - this requires screen sharing permission
                AppState.speakerStream = await navigator.mediaDevices.getDisplayMedia({
                    video: false,
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        systemAudio: 'include'  // Try to include system audio
                    }
                });
                
                // Check if we actually got audio
                const audioTracks = AppState.speakerStream.getAudioTracks();
                if (audioTracks.length === 0) {
                    throw new Error('No audio tracks in display media');
                }
                
                AppState.speakerAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                AppState.speakerAnalyser = AppState.speakerAudioContext.createAnalyser();
                const speakerSource = AppState.speakerAudioContext.createMediaStreamSource(AppState.speakerStream);
                speakerSource.connect(AppState.speakerAnalyser);
                
                AppState.speakerAnalyser.fftSize = 512;
                AppState.speakerAnalyser.smoothingTimeConstant = 0.3;
                
                startCallDetection();
                showNotification('ÔøΩ Speaker audio enabled - Auto call detection active!', 'success', 3000);
                
            } catch (error) {
                console.warn('Speaker audio access not available:', error);
                showNotification('üîä Speaker detection unavailable - Manual start only', 'error', 3000);
                // Fall back to manual controls only
            }
        }

        function startVoiceDetection() {
            const bufferLength = AppState.micAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function detectVoice() {
                if (!AppState.micAnalyser) return;
                
                AppState.micAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                
                const wasSpeaking = AppState.micActive;
                AppState.micActive = average > AppState.speechThreshold;
                
                // Update mic status indicator
                const micStatus = document.getElementById('mic-status');
                if (AppState.micActive) {
                    micStatus.classList.add('active');
                    // Auto-reset timer when your voice is detected
                    if (!wasSpeaking && AppState.timerRunning) {
                        resetTimer();
                    }
                } else {
                    micStatus.classList.remove('active');
                }
                
                requestAnimationFrame(detectVoice);
            }
            
            detectVoice();
            showNotification('üé§ Voice detection active', 'success', 2000);
        }

        function startCallDetection() {
            const bufferLength = AppState.speakerAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            let loudSoundCount = 0;
            let lastLoudSoundTime = 0;
            
            function detectCall() {
                if (!AppState.speakerAnalyser) return;
                
                AppState.speakerAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                const currentTime = Date.now();
                
                // Detect loud sounds from speakers (beep + announcement)
                const isLoudSound = average > AppState.loudSoundThreshold;
                
                // Auto-start timer when call is detected
                if (!AppState.callDetected && AppState.autoStartEnabled) {
                    if (isLoudSound) {
                        loudSoundCount++;
                        lastLoudSoundTime = currentTime;
                        
                        // If we detect sustained loud audio (beep + announcement)
                        if (loudSoundCount >= 3 && !AppState.timerRunning) {
                            AppState.callDetected = true;
                            startTimer();
                            showNotification('üìû Call detected - Timer started automatically!', 'success', 3000);
                        }
                    } else {
                        // Reset if silence for too long
                        if (currentTime - lastLoudSoundTime > 3000) {
                            loudSoundCount = 0;
                        }
                    }
                }
                
                requestAnimationFrame(detectCall);
            }
            
            detectCall();
        }

        function toggleAutoStart() {
            AppState.autoStartEnabled = !AppState.autoStartEnabled;
            const status = AppState.autoStartEnabled ? 'enabled' : 'disabled';
            showNotification(`Auto-start on call detection ${status}`, 'success', 2000);
        }

        function resetCallDetection() {
            AppState.callDetected = false;
            AppState.timerRunning = false;
            AppState.deadAirSeconds = 0;
            
            // Clear the timer interval
            if (AppState.deadAirTimer) {
                clearInterval(AppState.deadAirTimer);
                AppState.deadAirTimer = null;
            }
            
            // Clear session infractions at end of call
            AppState.sessionInfractions = 0;
            updateInfractionDisplay();
            
            updateTimerDisplay();
            updateTimerVisuals();
            showNotification('Call ended - Timer stopped and reset', 'success', 2000);
        }

        // Infraction tracking functions
        function recordInfraction() {
            AppState.sessionInfractions++;
            AppState.totalInfractions++;
            
            // Save total to localStorage
            localStorage.setItem('totalInfractions', AppState.totalInfractions.toString());
            
            updateInfractionDisplay();
            showNotification('‚ö†Ô∏è Dead air infraction recorded (30+ seconds)', 'error', 3000);
        }

        function clearLastInfraction() {
            if (AppState.sessionInfractions > 0) {
                AppState.sessionInfractions--;
                AppState.totalInfractions--;
                
                // Update localStorage
                localStorage.setItem('totalInfractions', AppState.totalInfractions.toString());
                
                updateInfractionDisplay();
                showNotification('‚úÖ Last infraction cleared', 'success', 2000);
            } else {
                showNotification('‚ùå No infractions to clear', 'error', 2000);
            }
        }

        function clearTotalInfractions() {
            if (confirm('Clear all total infractions? This cannot be undone.')) {
                AppState.totalInfractions = 0;
                localStorage.setItem('totalInfractions', '0');
                updateInfractionDisplay();
                showNotification('üóëÔ∏è Total infractions cleared', 'success', 2000);
            }
        }

        function updateInfractionDisplay() {
            const sessionCount = document.getElementById('session-count');
            const totalCount = document.getElementById('total-count');
            const tracker = document.getElementById('infraction-tracker');
            
            if (sessionCount) sessionCount.textContent = AppState.sessionInfractions;
            if (totalCount) totalCount.textContent = AppState.totalInfractions;
            
            // Add visual emphasis when there are infractions
            if (tracker) {
                if (AppState.sessionInfractions > 0) {
                    tracker.classList.add('has-infractions');
                } else {
                    tracker.classList.remove('has-infractions');
                }
            }
        }

        function loadTotalInfractions() {
            const saved = localStorage.getItem('totalInfractions');
            if (saved) {
                AppState.totalInfractions = parseInt(saved) || 0;
            }
        }

        // Token obfuscation utilities
        function encodeToken(token) {
            // Simple XOR + Base64 encoding (not cryptographically secure, just obfuscation)
            const key = 42; // Simple XOR key
            const xored = token.split('').map(char => 
                String.fromCharCode(char.charCodeAt(0) ^ key)
            ).join('');
            return btoa(xored);
        }

        function decodeToken(maskedToken) {
            try {
                const key = 42; // Same XOR key
                const decoded = atob(maskedToken);
                return decoded.split('').map(char => 
                    String.fromCharCode(char.charCodeAt(0) ^ key)
                ).join('');
            } catch (error) {
                console.warn('Token decode failed:', error);
                return null;
            }
        }

        function initializeGitHubToken() {
            // Try to decode the masked token first
            if (AppState.maskedToken && AppState.maskedToken !== 'Z2hwX0VYQU1QTEVfVE9LRU5fUkVQTEFDRV9NRQ==') {
                const decodedToken = decodeToken(AppState.maskedToken);
                if (decodedToken && decodedToken.startsWith('ghp_')) {
                    AppState.githubToken = decodedToken;
                    console.log('GitHub token loaded from masked token');
                    return;
                }
            }
            
            // Fall back to saved token in localStorage
            const savedToken = localStorage.getItem('githubToken');
            if (savedToken) {
                AppState.githubToken = savedToken;
                console.log('GitHub token loaded from localStorage');
            }
        }
        // Version comparison utility
        function isNewerVersion(remote, current) {
            const parseVersion = (v) => v.split('.').map(n => parseInt(n) || 0);
            const [rMajor, rMinor, rPatch] = parseVersion(remote);
            const [cMajor, cMinor, cPatch] = parseVersion(current);
            
            if (rMajor > cMajor) return true;
            if (rMajor < cMajor) return false;
            if (rMinor > cMinor) return true;
            if (rMinor < cMinor) return false;
            return rPatch > cPatch;
        }

        async function checkForUpdates() {
            if (!AppState.autoUpdateEnabled) return;
            
            const updateBtn = document.getElementById('update-btn');
            const updateIcon = document.getElementById('update-icon');
            const updateBtnTop = document.getElementById('update-btn-top');
            const updateIconTop = document.getElementById('update-icon-top');
            
            // Add visual feedback to both buttons
            if (updateBtn && updateIcon) {
                updateBtn.disabled = true;
                updateIcon.classList.add('fa-spin');
                updateBtn.style.opacity = '0.7';
            }
            if (updateBtnTop && updateIconTop) {
                updateBtnTop.disabled = true;
                updateIconTop.classList.add('fa-spin');
                updateBtnTop.style.opacity = '0.7';
            }
            
            try {
                console.log('Checking for updates...');
                showNotification('Checking for updates...', 'info');
                
                // GitHub API URL for the raw file
                const apiUrl = `https://api.github.com/repos/${AppState.githubRepo}/contents/IGAPP.html`;
                
                // Headers for API request
                const headers = {
                    'Accept': 'application/vnd.github.v3+json',
                    'User-Agent': 'IGAPP-AutoUpdater'
                };
                
                // Add authentication for private repo
                if (AppState.githubToken) {
                    headers['Authorization'] = `token ${AppState.githubToken}`;
                }
                
                const response = await fetch(apiUrl, { headers });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        showNotification('üîí Update check failed: Authentication required for private repo', 'error', 5000);
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const remoteContent = atob(data.content.replace(/\s/g, ''));
                
                // Extract version from remote content
                const versionMatch = remoteContent.match(/currentVersion:\s*['"`]([^'"`]+)['"`]/);
                const remoteVersion = versionMatch ? versionMatch[1] : null;
                
                if (remoteVersion && isNewerVersion(remoteVersion, AppState.currentVersion)) {
                    showUpdateAvailable(remoteVersion, remoteContent);
                } else {
                    console.log('App is up to date');
                    showNotification('‚úÖ App is up to date', 'success', 2000);
                    // Hide the static update button since no update is available
                    const staticUpdateBtn = document.getElementById('update-btn');
                    if (staticUpdateBtn) {
                        staticUpdateBtn.style.display = 'none';
                    }
                }
                
            } catch (error) {
                console.warn('Update check failed:', error);
                showNotification('‚ö†Ô∏è Update check failed - Check connection', 'error', 3000);
            } finally {
                // Reset button state for both buttons
                if (updateBtn && updateIcon) {
                    updateBtn.disabled = false;
                    updateIcon.classList.remove('fa-spin');
                    updateBtn.style.opacity = '1';
                }
                if (updateBtnTop && updateIconTop) {
                    updateBtnTop.disabled = false;
                    updateIconTop.classList.remove('fa-spin');
                    updateBtnTop.style.opacity = '1';
                }
            }
        }

        function showUpdateAvailable(newVersion, newContent) {
            const updateMessage = `üöÄ Update available: v${newVersion} (current: v${AppState.currentVersion})`;
            showNotification(updateMessage, 'success', 10000);
            
            // Show the static update button
            const staticUpdateBtn = document.getElementById('update-btn');
            if (staticUpdateBtn) {
                staticUpdateBtn.style.display = 'flex';
                staticUpdateBtn.innerHTML = `<i class="fas fa-sync-alt" id="update-icon" aria-hidden="true"></i><span>Update to v${newVersion}</span>`;
            }
            
            // Add dynamic update button to page
            addUpdateButton(newVersion, newContent);
        }

        function addUpdateButton(newVersion, newContent) {
            // Remove existing dynamic update button if present
            const existingBtn = document.getElementById('dynamic-update-btn');
            if (existingBtn) existingBtn.remove();
            
            // Don't show button if already up to date
            if (!isNewerVersion(newVersion, AppState.currentVersion)) {
                return;
            }
            
            // Create primary copy button (better for preserving encoding)
            const copyBtn = document.createElement('button');
            copyBtn.className = 'dynamic-update-button';
            copyBtn.innerHTML = `ÔøΩ Copy v${newVersion} Code`;
            copyBtn.onclick = () => copyUpdateToClipboard(newContent, newVersion);
            copyBtn.setAttribute('aria-label', `Copy version ${newVersion} code to clipboard`);
            
            // Create alternative download button
            const downloadBtn = document.createElement('button');
            downloadBtn.id = 'dynamic-update-btn';
            downloadBtn.className = 'dynamic-update-button-alt';
            downloadBtn.innerHTML = `ÔøΩ Download v${newVersion}`;
            downloadBtn.onclick = () => applyUpdate(newContent, newVersion);
            downloadBtn.setAttribute('aria-label', `Download application version ${newVersion}`);
            
            // Create instructions
            const instructions = document.createElement('div');
            instructions.className = 'update-instructions';
            instructions.innerHTML = `
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                    Copy code (recommended) or download file<br>
                    Then replace this file and refresh
                </div>
            `;
            
            // Add to page
            document.body.appendChild(copyBtn);
            document.body.appendChild(downloadBtn);
            document.body.appendChild(instructions);
        }

        function copyUpdateToClipboard(newContent, newVersion) {
            navigator.clipboard.writeText(newContent).then(() => {
                showNotification(`üìã v${newVersion} code copied to clipboard!`, 'success', 5000);
                
                // Show instructions
                const instructions = `
Instructions for manual update:
1. Select all text in this file (Ctrl+A)
2. Delete all content (Delete key)
3. Paste the new code (Ctrl+V)
4. Save the file (Ctrl+S)
5. Refresh the page (F5)

This method preserves all icons and emojis correctly.
                `.trim();
                
                alert(instructions);
                
                // Remove update UI
                const copyBtn = document.querySelector('.dynamic-update-button');
                if (copyBtn) copyBtn.remove();
                const downloadBtn = document.getElementById('dynamic-update-btn');
                if (downloadBtn) downloadBtn.remove();
                const inst = document.querySelector('.update-instructions');
                if (inst) inst.remove();
                
            }).catch(() => {
                showNotification('‚ùå Failed to copy to clipboard', 'error', 3000);
            });
        }

        // Temporary export function for notes analysis
        function exportNotesData() {
            try {
                // Debug: Check all localStorage keys
                const allLocalStorageKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    allLocalStorageKeys.push(localStorage.key(i));
                }
                
                // Try different possible localStorage keys
                const possibleKeys = ['savedNotes', 'notes', 'history', 'formData', 'IGAPP_notes', 'notesHistory'];
                const foundData = {};
                
                possibleKeys.forEach(key => {
                    try {
                        const data = localStorage.getItem(key);
                        if (data) {
                            foundData[key] = JSON.parse(data);
                        }
                    } catch (e) {
                        foundData[key] = localStorage.getItem(key); // Store as string if not JSON
                    }
                });
                
                // Collect all notes data
                const savedNotesData = JSON.parse(localStorage.getItem('savedNotes') || '[]');
                const exportData = {
                    timestamp: new Date().toISOString(),
                    currentVersion: AppState.currentVersion,
                    currentNotes: document.getElementById('notes').value,
                    savedNotes: savedNotesData,
                    totalSavedNotes: savedNotesData.length,
                    sessionInfractions: AppState.sessionInfractions,
                    totalInfractions: AppState.totalInfractions,
                    selectedTags: Array.from(AppState.selectedTags || []),
                    
                    // Debug info
                    debug: {
                        allLocalStorageKeys: allLocalStorageKeys,
                        foundDataInKeys: foundData,
                        historyDropdownOptions: getHistoryDropdownContent()
                    },
                    
                    // Usage statistics
                    notesHistory: savedNotesData.map(note => ({
                        date: note.date,
                        length: note.notes ? note.notes.length : 0,
                        hasDAE: note.dae ? note.dae.length > 0 : false,
                        techName: note.techName ? 'present' : 'empty',
                        storeNumber: note.storeNumber ? 'present' : 'empty',
                        workOrder: note.workOrder ? 'present' : 'empty'
                    })),
                    
                    // Most common words/phrases analysis
                    commonPhrases: analyzeCommonPhrases(savedNotesData)
                };

                // Create formatted export with all actual notes content
                let exportText = `
=== IGAPP NOTES DATA EXPORT ===
Export Date: ${exportData.timestamp}
App Version: ${exportData.currentVersion}

=== DEBUG INFORMATION ===
All localStorage keys found: ${exportData.debug.allLocalStorageKeys.join(', ')}

Data found in potential keys:
${Object.keys(exportData.debug.foundDataInKeys).map(key => 
    `${key}: ${Array.isArray(exportData.debug.foundDataInKeys[key]) ? 
        `Array with ${exportData.debug.foundDataInKeys[key].length} items` : 
        typeof exportData.debug.foundDataInKeys[key]}`
).join('\n')}

History dropdown content: ${exportData.debug.historyDropdownOptions}

=== CURRENT SESSION ===
Current Notes Length: ${exportData.currentNotes.length} characters
Current Notes Content:
${exportData.currentNotes || '(No current notes)'}

Session Infractions: ${exportData.sessionInfractions}
Total Infractions: ${exportData.totalInfractions}
Selected Tags: ${exportData.selectedTags.join(', ') || 'None'}

=== ALL SAVED NOTES (${exportData.totalSavedNotes} total) ===
`;

                // Add each saved note with full content
                savedNotesData.forEach((note, index) => {
                    exportText += `
--- Note ${index + 1} (${note.date}) ---
Tech Name: ${note.techName || '(not provided)'}
Store Number: ${note.storeNumber || '(not provided)'}
Work Order: ${note.workOrder || '(not provided)'}

DAE Content:
${note.dae || '(no DAE content)'}

Notes Content:
${note.notes || '(no notes content)'}

Tags: ${note.tags ? note.tags.join(', ') : '(no tags)'}
---------------------------------
`;
                });

                exportText += `

=== USAGE STATISTICS ===
Total Saved Notes: ${exportData.totalSavedNotes}
Notes with DAE: ${exportData.notesHistory.filter(n => n.hasDAE).length}
Notes with Tech Name: ${exportData.notesHistory.filter(n => n.techName === 'present').length}
Notes with Store Number: ${exportData.notesHistory.filter(n => n.storeNumber === 'present').length}
Notes with Work Order: ${exportData.notesHistory.filter(n => n.workOrder === 'present').length}

Average Notes Length: ${exportData.notesHistory.length > 0 ? Math.round(exportData.notesHistory.reduce((sum, n) => sum + n.length, 0) / exportData.notesHistory.length) : 0} characters

=== COMMON PHRASES ===
${exportData.commonPhrases.join('\n')}

=== RAW DATA (JSON) ===
${JSON.stringify(exportData, null, 2)}
`;

                // Copy to clipboard
                navigator.clipboard.writeText(exportText).then(() => {
                    showNotification(`üìä Debug export complete! Found ${allLocalStorageKeys.length} localStorage keys`, 'success', 5000);
                    alert(`Debug export copied to clipboard!\n\nThis includes:\n- Debug info about localStorage\n- ${exportData.totalSavedNotes} saved notes\n- All available data keys\n\nThis will help identify where your notes are stored.`);
                }).catch(() => {
                    // Fallback: download as file
                    const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `IGAPP_Debug_Export_${new Date().toISOString().split('T')[0]}.txt`;
                    link.click();
                    URL.revokeObjectURL(url);
                    showNotification(`üìä Debug data downloaded as file!`, 'success', 5000);
                });

            } catch (error) {
                console.error('Export failed:', error);
                showNotification('‚ùå Export failed: ' + error.message, 'error', 5000);
            }
        }

        function getHistoryDropdownContent() {
            try {
                const historyDropdown = document.getElementById('history');
                if (historyDropdown) {
                    const options = Array.from(historyDropdown.options).map(option => option.text);
                    return options.join(', ');
                }
                return 'History dropdown not found';
            } catch (error) {
                return 'Error reading history dropdown: ' + error.message;
            }
        }

        function analyzeCommonPhrases(savedNotesData) {
            try {
                if (!savedNotesData || savedNotesData.length === 0) {
                    return ['No saved notes available for analysis'];
                }

                const allNotesText = savedNotesData.map(note => (note.notes || '') + ' ' + (note.dae || '')).join(' ').toLowerCase();
                
                if (!allNotesText.trim()) {
                    return ['No notes content available for analysis'];
                }

                // Common technical phrases to look for
                const commonPatterns = [
                    /logged into \w+/gi,
                    /called \w+/gi,
                    /contacted \w+/gi,
                    /replaced \w+/gi,
                    /tested \w+/gi,
                    /checked \w+/gi,
                    /updated \w+/gi,
                    /installed \w+/gi,
                    /configured \w+/gi,
                    /troubleshoot\w*/gi,
                    /issue with \w+/gi,
                    /problem with \w+/gi,
                    /error \w+/gi,
                    /\d{4,}/gi // Store numbers
                ];

                const foundPhrases = [];
                commonPatterns.forEach(pattern => {
                    const matches = allNotesText.match(pattern);
                    if (matches) {
                        foundPhrases.push(...matches);
                    }
                });

                if (foundPhrases.length === 0) {
                    return ['No common technical phrases found'];
                }

                // Count frequency and return top phrases
                const frequency = {};
                foundPhrases.forEach(phrase => {
                    const cleanPhrase = phrase.trim();
                    frequency[cleanPhrase] = (frequency[cleanPhrase] || 0) + 1;
                });

                return Object.entries(frequency)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 20)
                    .map(([phrase, count]) => `"${phrase}" (used ${count} times)`);

            } catch (error) {
                return ['Error analyzing phrases: ' + error.message];
            }
        }

        function applyUpdate(newContent, newVersion) {
            const updateChoice = confirm(`Update to version ${newVersion}?\n\nThis will download the new version. You'll need to replace your current file manually.`);
            if (!updateChoice) {
                return;
            }
            
            try {
                // Get the current file name
                const currentFileName = window.location.pathname.split('/').pop() || 'IGAPP.html';
                
                // Create a blob with proper UTF-8 encoding
                const blob = new Blob([newContent], { 
                    type: 'text/html;charset=utf-8' 
                });
                const url = URL.createObjectURL(blob);
                
                // Create a download link
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = currentFileName;
                downloadLink.style.display = 'none';
                
                // Add to page, click, and remove
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // Clean up the URL object
                URL.revokeObjectURL(url);
                
                // Show detailed instructions
                showUpdateInstructions(newVersion, currentFileName);
                
                // Remove the update button since update is "applied"
                const dynamicBtn = document.getElementById('dynamic-update-btn');
                if (dynamicBtn) dynamicBtn.remove();
                
                // Remove instructions too
                const instructions = document.querySelector('.update-instructions');
                if (instructions) instructions.remove();
                
            } catch (error) {
                console.error('Update download failed:', error);
                showNotification('‚ùå Update download failed - Please try again', 'error', 5000);
            }
        }

        function showUpdateInstructions(newVersion, fileName) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'update-modal-overlay';
            overlay.innerHTML = `
                <div class="update-modal">
                    <h3>üéâ v${newVersion} Downloaded!</h3>
                    <div class="update-steps">
                        <div class="update-note">
                            ‚ö†Ô∏è <strong>Important:</strong> If icons appear as strange text after updating, use the "Copy Code" method instead for better character encoding.
                        </div>
                        <p><strong>Follow these steps to complete the update:</strong></p>
                        <ol>
                            <li>üìÅ Go to your Downloads folder</li>
                            <li>üîç Find the file: <code>${fileName}</code></li>
                            <li>üìã Copy this new file</li>
                            <li>üìÇ Navigate to where your current IGAPP file is located</li>
                            <li>üîÑ Replace the old file with the new one</li>
                            <li>üîÑ Refresh this page (F5 or Ctrl+R)</li>
                        </ol>
                        <p><strong>Alternative:</strong> Use the "üìã Copy Code" button for better character preservation.</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="update-modal-btn">Got it!</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }

        function setGitHubToken() {
            const token = prompt('Enter your GitHub Personal Access Token for private repo access:\n\n(Leave blank to cancel)');
            if (token && token.trim()) {
                AppState.githubToken = token.trim();
                localStorage.setItem('githubToken', AppState.githubToken);
                showNotification('üîë GitHub token saved - Updates enabled', 'success', 3000);
                checkForUpdates();
            }
        }

        function toggleAutoUpdate() {
            AppState.autoUpdateEnabled = !AppState.autoUpdateEnabled;
            localStorage.setItem('autoUpdateEnabled', AppState.autoUpdateEnabled.toString());
            
            const status = AppState.autoUpdateEnabled ? 'enabled' : 'disabled';
            showNotification(`üîÑ Auto-updates ${status}`, 'success', 2000);
        }

        // VCC Integration Methods
        function initializeVCCIntegration() {
            console.log('VCC Integration: Browser audio capture requires Google sign-in');
            console.log('Using manual VCC controls only');
            
            // Add VCC call control button
            addVCCManualButton();
            
            // Add helpful keyboard shortcuts reminder
            setTimeout(() => {
                showNotification('üí° VCC Tips: Use VCC button or Spacebar for manual control', 'success', 4000);
            }, 2000);
            
            // Add info about Google sign-in requirement
            setTimeout(() => {
                showNotification('‚ÑπÔ∏è Auto-detection needs Google sign-in for audio access', 'error', 5000);
            }, 7000);
            
            console.log('VCC manual integration ready');
        }

        function initializeVCCWindowDetection() {
            let windowFocusLost = null;
            let windowBlurCount = 0;
            
            // Monitor rapid window focus changes (VCC often steals focus)
            window.addEventListener('blur', function() {
                windowFocusLost = Date.now();
                windowBlurCount++;
                console.log('Window blur detected, count:', windowBlurCount);
                
                // If multiple rapid blurs, might be VCC activity
                setTimeout(() => {
                    if (windowBlurCount >= 2) {
                        showNotification('üîÑ Multiple window changes - VCC activity detected?', 'success', 3000);
                        windowBlurCount = 0;
                    }
                }, 3000);
            });
            
            window.addEventListener('focus', function() {
                if (windowFocusLost) {
                    const focusTime = Date.now() - windowFocusLost;
                    console.log('Window focus returned after:', focusTime, 'ms');
                    
                    // If focus was lost for a typical call duration (5+ seconds)
                    if (focusTime > 5000 && focusTime < 30000) {
                        showNotification('ÔøΩ Focus returned - Was that a VCC call?', 'success', 3000);
                    }
                    windowFocusLost = null;
                }
            });
            
            // Monitor for page visibility changes (VCC switching tabs)
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    console.log('Page hidden - VCC might be active');
                } else {
                    console.log('Page visible - Back from VCC?');
                    showNotification('üëÄ Page visible - Back from VCC call?', 'success', 2000);
                }
            });
        }

        function addVCCManualButton() {
            // Add VCC call control button to timer controls
            const timerControls = document.querySelector('.timer-controls');
            if (timerControls && !document.getElementById('vcc-manual-btn')) {
                const vccButton = document.createElement('button');
                vccButton.id = 'vcc-manual-btn';
                vccButton.className = 'timer-btn';
                vccButton.onclick = toggleVCCMode;
                vccButton.title = 'Start VCC Call';
                vccButton.textContent = 'VCC';
                timerControls.appendChild(vccButton);
            }
        }

        function toggleVCCMode() {
            if (!AppState.timerRunning) {
                // Start VCC call mode
                startTimer();
                AppState.callDetected = true;
                const btn = document.getElementById('vcc-manual-btn');
                if (btn) {
                    btn.textContent = 'END';
                    btn.style.background = 'rgba(220, 53, 69, 0.3)';
                    btn.title = 'End VCC Call';
                }
                showNotification('üìû VCC Call Started', 'success', 2000);
            } else {
                // End VCC call mode  
                resetCallDetection();
                const btn = document.getElementById('vcc-manual-btn');
                if (btn) {
                    btn.textContent = 'VCC';
                    btn.style.background = '';
                    btn.title = 'Start VCC Call';
                }
                showNotification('üìû VCC Call Ended', 'success', 2000);
            }
        }

        function monitorVCCAudio() {
            console.log('Starting VCC audio monitoring...');
            
            const bufferLength = AppState.micAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            let callBeepDetected = false;
            let consecutiveHighAudio = 0;
            let lastAudioLevel = 0;
            let logCount = 0;
            
            function detectVCCCall() {
                if (!AppState.micAnalyser) {
                    console.log('No mic analyser available');
                    return;
                }
                
                AppState.micAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                
                // Debug: Log audio levels more frequently initially, then every 5 seconds
                logCount++;
                if (logCount <= 20 || logCount % 50 === 0) {
                    console.log(`Audio level: ${Math.round(average)}, Threshold: 60, High threshold: 30, Buffer length: ${bufferLength}`);
                }
                
                // Also log when there are significant changes
                if (Math.abs(average - lastAudioLevel) > 10) {
                    console.log(`Audio level changed: ${Math.round(lastAudioLevel)} ‚Üí ${Math.round(average)}`);
                    lastAudioLevel = average;
                }
                
                // VCC high audio detection (original threshold)
                if (average > 60) {
                    consecutiveHighAudio++;
                    console.log(`HIGH audio detected: ${Math.round(average)}, consecutive: ${consecutiveHighAudio}`);
                    
                    if (consecutiveHighAudio >= 3 && !AppState.timerRunning && AppState.autoStartEnabled) {
                        console.log('üéØ VCC CALL DETECTED - Starting timer!');
                        showNotification('üìû VCC audio spike detected - Starting timer!', 'success', 3000);
                        startTimer();
                        callBeepDetected = true;
                    }
                } else if (average > 30) {
                    // Medium audio detection (lower threshold)
                    if (consecutiveHighAudio > 0 || average > 40) {
                        console.log(`MEDIUM audio detected: ${Math.round(average)}`);
                        showNotification('üéµ Audio activity - Possible VCC call', 'success', 2000);
                    }
                    consecutiveHighAudio = Math.max(0, consecutiveHighAudio - 1);
                } else if (average > 15) {
                    // Low audio detection (any activity)
                    if (logCount <= 20 || logCount % 100 === 0) {
                        console.log(`Low audio activity: ${Math.round(average)}`);
                    }
                    consecutiveHighAudio = 0;
                } else {
                    consecutiveHighAudio = 0;
                }
                
                requestAnimationFrame(detectVCCCall);
            }
            
            detectVCCCall();
            console.log('VCC audio monitoring started successfully');
        }

        // Enhanced Quick Notes to auto-reset timer
        function addQuickNote(noteText) {
            const notesTextarea = document.getElementById('notes');
            const currentNotes = notesTextarea.value.trim();
            
            if (currentNotes) {
                notesTextarea.value = currentNotes + ' ' + noteText;
            } else {
                notesTextarea.value = noteText;
            }
            
            // Auto-reset dead air timer (indicates speaking)
            if (AppState.timerRunning) {
                resetTimer();
            }
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Update tag recommendations after adding note
            analyzeNotesForTags();
            
            // Visual feedback
            showNotification(`Added: ${noteText}`, 'success', 2000);
            
            // Scroll to end of textarea
            notesTextarea.scrollTop = notesTextarea.scrollHeight;
            notesTextarea.setSelectionRange(notesTextarea.value.length, notesTextarea.value.length);
        }

        // Utility functions
        function showNotification(message, type = 'success', duration = 3000) {
            // Create notification container if it doesn't exist
            let notificationContainer = document.querySelector('.notification-container');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.className = 'notification-container';
                document.body.appendChild(notificationContainer);
            }

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.setAttribute('role', 'alert');
            notification.setAttribute('aria-live', 'polite');
            
            // Insert at the beginning (top) to push others down
            notificationContainer.insertBefore(notification, notificationContainer.firstChild);
            
            // Trigger animation
            setTimeout(() => notification.classList.add('show'), 100);
            
            // Auto remove
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        notification.remove();
                        // Remove container if empty
                        if (notificationContainer.children.length === 0) {
                            notificationContainer.remove();
                        }
                    }, 300);
                }
            }, duration);
        }

        function addButtonFeedback(button, type = 'success') {
            const originalClass = button.className;
            button.classList.add(`${type}-feedback`);
            setTimeout(() => {
                button.className = originalClass;
            }, 200);
        }

        function validateInput(value, type = 'text') {
            if (type === 'storeNumber') {
                return /^\d+$/.test(value) || value === '';
            }
            return true;
        }

        // Enhanced theme management
        function toggleTheme() {
            try {
                const body = document.body;
                const button = document.getElementById('theme-toggle-btn');
                
                body.classList.toggle('light-mode');
                body.classList.toggle('dark-mode');
                const isDark = body.classList.contains('dark-mode');
                
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                updateThemeIcon(isDark);
                
                // Update button aria-label
                button.setAttribute('aria-label', 
                    isDark ? 'Switch to light mode' : 'Switch to dark mode'
                );
                
                showNotification(`Switched to ${isDark ? 'dark' : 'light'} mode`, 'success', 1500);
            } catch (error) {
                console.error('Theme toggle failed:', error);
                showNotification('Failed to toggle theme', 'error');
            }
        }

        function updateThemeIcon(isDark) {
            const icon = document.getElementById('theme-toggle-icon');
            if (icon) {
                if (isDark) {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                } else {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                }
            }
        }

        // Enhanced history management with better error handling
        function saveNotesHistory() {
            try {
                const formData = getFormData();
                
                if (!hasValidData(formData)) {
                    return false;
                }

                const noteEntry = {
                    ...formData,
                    timestamp: Date.now(),
                    id: generateId()
                };

                let history = getNotesHistory();
                history = cleanOldEntries(history);
                
                // Prevent duplicate entries
                const isDuplicate = history.some(entry => 
                    entry.techName === formData.techName &&
                    entry.storeNumber === formData.storeNumber &&
                    entry.workOrder === formData.workOrder &&
                    Math.abs(entry.timestamp - noteEntry.timestamp) < 60000 // Within 1 minute
                );
                
                if (!isDuplicate) {
                    history.push(noteEntry);
                    localStorage.setItem('notesHistory', JSON.stringify(history));
                    updateHistoryDropdown();
                }
                
                return true;
            } catch (error) {
                console.error('Failed to save notes history:', error);
                showNotification('Failed to save to history', 'error');
                return false;
            }
        }

        function getFormData() {
            return {
                techName: document.getElementById('tech-name').value.trim(),
                storeNumber: document.getElementById('store-number').value.trim(),
                workOrder: document.getElementById('work-order').value.trim(),
                notes: document.getElementById('notes').value.trim()
            };
        }

        function hasValidData(data) {
            return Object.values(data).some(value => value.length > 0);
        }

        function getNotesHistory() {
            try {
                return JSON.parse(localStorage.getItem('notesHistory') || '[]');
            } catch (error) {
                console.error('Failed to parse notes history:', error);
                return [];
            }
        }

        function cleanOldEntries(history) {
            const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
            return history.filter(entry => Date.now() - entry.timestamp <= sevenDaysInMs);
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function updateHistoryDropdown() {
            try {
                const history = getNotesHistory();
                const historySelect = document.getElementById('history');
                
                if (!historySelect) return;
                
                historySelect.innerHTML = '<option value="">-- Select Previous Notes --</option>';
                
                // Sort by timestamp (newest first)
                const sortedHistory = history.sort((a, b) => b.timestamp - a.timestamp);
                
                sortedHistory.forEach((entry) => {
                    const date = new Date(entry.timestamp).toLocaleString();
                    // Truncate techName and storeNumber for better readability
                    let techName = entry.techName || 'No Name';
                    let storeNumber = entry.storeNumber || 'N/A';
                    if (techName.length > 18) techName = techName.substring(0, 15) + '...';
                    if (storeNumber.length > 10) storeNumber = storeNumber.substring(0, 10) + '...';
                    const label = `${date} - ${techName} (Store: ${storeNumber})`;
                    const option = document.createElement('option');
                    option.value = entry.id;
                    option.textContent = label;
                    historySelect.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to update history dropdown:', error);
            }
        }

        function restoreNotes() {
            try {
                const historySelect = document.getElementById('history');
                const selectedId = historySelect.value;
                if (!selectedId) return;

                const history = getNotesHistory();
                const entry = history.find(e => e.id === selectedId);
                
                if (entry) {
                    document.getElementById('tech-name').value = entry.techName || '';
                    document.getElementById('store-number').value = entry.storeNumber || '';
                    document.getElementById('work-order').value = entry.workOrder || '';
                    document.getElementById('notes').value = entry.notes || '';
                    
                    showNotification('Notes restored successfully', 'success', 2000);
                    
                    // Auto-save after restore
                    scheduleAutoSave();
                }
            } catch (error) {
                console.error('Failed to restore notes:', error);
                showNotification('Failed to restore notes', 'error');
            }
        }

        // Helper for DAE notes overwrite confirmation
        function shouldOverwriteDAENotes(notesBox) {
            // Returns true if it's safe to overwrite, or user confirms overwrite
            if (!notesBox.dataset.userEdited || notesBox.dataset.userEdited === 'false' || !notesBox.value.trim()) {
                return true;
            }
            return confirm('This will overwrite your current DAE notes. Continue?');
        }

        // DAE Templates managed in JavaScript for maintainability
        const DAE_TEMPLATES = {
            "Help Desk Post": `Store # 
EMS - 
WO# - 
Issue - 
What have you done? 
Wiki Link Used - 
Any screenshots of issue.:`,

            "Condenser and Compressor Staging Changes": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:`,

            "Changes to Rack Suction Settings": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:`,

            "Reporting Issues with IoT": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed error description:
Screenshots of the error in IoT as well as any supporting screenshots from the EMS system. Paste them into a Word doc and attach it to the work order when you create it.:`,

            "Setting MAC Addresses": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
New device type and position (For example, Novar ES1 on rack LTB or Emerson E2E on HVAC):
MAC address of the new device (must be 12 characters):
Old MAC address:`,

            "Controller COMM Loss": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
Is the ethernet cable plugged into the device, yes or no?:
Controller type (Novar EP2, Emerson E2E, Danfoss AK255 etc.):
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Has the controller been power cycled, yes or no?:
Is the controller functioning normally per the technician? If not, please provide details.: 
MAC address (must be 12 characters):
The switch and Port controller goes to (if tech can provide):`,

            "Changing Board Points": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
Current module address and point number.:
New module address and point number.:`,

            "Carel BOSS Support": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Rack (LTA, MTB etc.):
Detailed description of technician request OR
If an alarm, include a screenshot of the alarm in IoT.:`,

            "Novar Download Failures": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Type of download needed (version, main, comm, etc.):
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Description of controller behavior or error messages received. Paste screenshots of error messages into a Word document and attach it to the work order as you create it.:`,

            "Danfoss Downloads": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
What system it controls (HVAC, Rack A, Rack B‚Ä¶etc.):
Description of what prompted the download request (Controller change out, controller software failure, etc.):
MAC address (must be 12 characters):`,

            "Manager Escalations": `Name of the manager or team lead authorizing the escalation:
Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed description of the issue:
What actions Contact Center agents have taken so far:
Any supporting screenshots of EMS systems or other documentation. Paste screenshots of error messages into a Word document and attach it to the work order as you create it.:`,

            "Program Change Request": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
What the technician has requested and the reason for the request:
A screenshot of the module in the EMS system.:`,

            "RTU Fans Mode": `Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
EMS system (Novar, Opus, CPC, Danfoss etc.):
What RTU fan(s) the technician has requested to turn off and the reason for the request.:`,

            "Parameter Deviation": `Name of the manager or team lead authorizing the escalation:
Technician first and last name:
Technician cell phone number:
Technician email address:
Store number:
WO:
Detailed description of request:
Current setpoint and requested setpoint:
Screenshots of setpoint in EMS system and of the Parameter Cutsheet.:`,

            "Swap Work Order": `Swap Workorder Notes Show: (Enter the notes from the email).
Please email acserv@wal-mart.com when service is complete. Please provide notes regarding work done along with on/off site dates and times. You may also contact Alarm Central at 479-273-4600, options 1 and 4 between the hours of 7AM-7PM CST Mon-Fri:`,

            "Mastermind Work Order": `Mastermind Report Notes Show: (Enter the notes from the work order attachment that is in all caps).
Please email acserv@wal-mart.com when service is complete. Please provide notes regarding work done along with on/off site dates and times. You may also contact Alarm Central at 479-273-4600, options 1 and 4 between the hours of 7AM-7PM CST Mon-Fri:`
        };
        
                // Quick Notes functionality
        function addQuickNote(noteText) {
            const notesTextarea = document.getElementById('notes');
            const currentNotes = notesTextarea.value.trim();
            
            if (currentNotes) {
                notesTextarea.value = currentNotes + ' ' + noteText;
            } else {
                notesTextarea.value = noteText;
            }
            
            // Trigger auto-save
            scheduleAutoSave();
            
            // Visual feedback
            showNotification(`Added: ${noteText}`, 'success', 2000);
            
            // Scroll to end of textarea
            notesTextarea.scrollTop = notesTextarea.scrollHeight;
            notesTextarea.setSelectionRange(notesTextarea.value.length, notesTextarea.value.length);
        }

        function addQuickNoteWithInput(prefix, prompt) {
            const userInput = window.prompt(prompt);
            if (userInput !== null && userInput.trim() !== '') {
                addQuickNote(prefix + userInput.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addForcedNote() {
            const parameter = window.prompt('What did you force?\n\nExamples:\n‚Ä¢ Suct PSI to 30\n‚Ä¢ OAT to 68 degrees\n‚Ä¢ Discharge temp to 105\n‚Ä¢ Fan speed to 75%');
            if (parameter !== null && parameter.trim() !== '') {
                addQuickNote('Forced ' + parameter.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addForcedOffNote() {
            const notesContent = document.getElementById('notes').value;
            const daeContent = document.getElementById('dropdown-notes').value;
            const combinedContent = notesContent + ' ' + daeContent;
            
            // Look for previously forced items in the notes
            const forcedOnRegex = /Forced (?:on )?([^.]+)\./gi;
            const matches = [];
            let match;
            
            while ((match = forcedOnRegex.exec(combinedContent)) !== null) {
                const item = match[1].trim();
                // Skip if it's already been forced off
                if (!combinedContent.toLowerCase().includes('forced off ' + item.toLowerCase())) {
                    matches.push(item);
                }
            }
            
            if (matches.length > 0) {
                // Use the most recent forced item
                const lastForcedItem = matches[matches.length - 1];
                addQuickNote('Forced off ' + lastForcedItem + '.');
                showNotification(`Auto-detected: ${lastForcedItem}`, 'success', 2000);
            } else {
                // No forced items found, prompt for input
                const item = window.prompt('What did you force off?\n\nExamples:\n‚Ä¢ Bypass Valve\n‚Ä¢ Compressor 2\n‚Ä¢ Fan speed\n‚Ä¢ lights');
                if (item !== null && item.trim() !== '') {
                    addQuickNote('Forced off ' + item.trim() + '.');
                }
            }
        }

        function addSetpointNote() {
            const coolTemp = window.prompt('Enter cooling setpoint (¬∞F):\n\nExample: 72');
            if (coolTemp === null || coolTemp.trim() === '') return;
            
            const heatTemp = window.prompt('Enter heating setpoint (¬∞F):\n\nExample: 68');
            if (heatTemp === null || heatTemp.trim() === '') return;
            
            const unit = window.prompt('Enter unit/RTU:\n\nExamples:\n‚Ä¢ RTU 1\n‚Ä¢ RTU 2\n‚Ä¢ HVAC Unit A\n‚Ä¢ Unit 3');
            if (unit === null || unit.trim() === '') return;
            
            const note = `Changed setpoint to ${coolTemp.trim()}/${heatTemp.trim()} for ${unit.trim()}.`;
            addQuickNote(note);
        }

        function addTestNote() {
            const component = window.prompt('What did you test?\n\nExamples:\n‚Ä¢ controller functionality\n‚Ä¢ sensor readings\n‚Ä¢ valve operation\n‚Ä¢ communication');
            if (component !== null && component.trim() !== '') {
                addQuickNote('Tested ' + component.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addMonitorNote() {
            const instruction = window.prompt('Monitor what?\n\nExamples:\n‚Ä¢ temperatures for 30 minutes\n‚Ä¢ system and call back if issues persist\n‚Ä¢ alarms overnight\n‚Ä¢ pressures during peak hours');
            if (instruction !== null && instruction.trim() !== '') {
                addQuickNote('Advised to monitor ' + instruction.trim() + '.');
            }
        }

        function showContactOptions() {
            const contacts = [
                'Docfit',
                'Service Channel', 
                'Copeland',
                'Sporlan',
                'Other'
            ];
            
            let message = 'Select who to contact:\n\n';
            contacts.forEach((contact, index) => {
                message += `${index + 1}. ${contact}\n`;
            });
            
            const choice = window.prompt(message + '\nEnter number (1-5):');
            
            if (choice !== null && choice.trim() !== '') {
                const choiceNum = parseInt(choice.trim());
                if (choiceNum >= 1 && choiceNum <= 4) {
                    addQuickNote('Advised tech to contact ' + contacts[choiceNum - 1] + '.');
                    // Tag analysis is handled by addQuickNote
                } else if (choiceNum === 5) {
                    const customContact = window.prompt('Enter contact details:');
                    if (customContact !== null && customContact.trim() !== '') {
                        addQuickNote('Advised tech to contact ' + customContact.trim() + '.');
                        // Tag analysis is handled by addQuickNote
                    }
                }
            }
        }

        function addContactNote() {
            const contact = window.prompt('Contact who?\n\nExamples:\n‚Ä¢ HVAC vendor\n‚Ä¢ facilities management\n‚Ä¢ IT support\n‚Ä¢ local technician');
            if (contact !== null && contact.trim() !== '') {
                addQuickNote('Advised tech to contact ' + contact.trim() + '.');
            }
        }

        function addReplaceNote() {
            const component = window.prompt('Replace what?\n\nExamples:\n‚Ä¢ temperature sensor\n‚Ä¢ controller board\n‚Ä¢ communication cable\n‚Ä¢ valve actuator');
            if (component !== null && component.trim() !== '') {
                addQuickNote('Advised to replace ' + component.trim() + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        function addEscalateNote() {
            // Get the selected DAE option
            const daeSelect = document.getElementById('autofill');
            const selectedDAE = daeSelect.value;
            
            let daeText = 'Created DAE';
            if (selectedDAE && selectedDAE.trim() !== '') {
                daeText = 'Created ' + selectedDAE + ' DAE';
            }
            
            // Prompt for work order number
            const workOrder = window.prompt('Enter Work Order number:');
            
            if (workOrder !== null && workOrder.trim() !== '') {
                addQuickNote(daeText + '. Created WO: ' + workOrder.trim() + '.');
                // Tag analysis is handled by addQuickNote
            } else {
                // If no WO provided, just add the DAE part
                addQuickNote(daeText + '.');
                // Tag analysis is handled by addQuickNote
            }
        }

        // Enhanced notes updating with validation
        function updateNotes() {
            try {
                const selectedOption = document.getElementById('autofill').value;
                if (!selectedOption) return;

                const notesBox = document.getElementById('dropdown-notes');
                const selectedText = DAE_TEMPLATES[selectedOption] || '';

                if (!selectedText) {
                    showNotification('Template not found', 'error');
                    return;
                }

                // Use helper for overwrite confirmation
                if (shouldOverwriteDAENotes(notesBox)) {
                    notesBox.value = selectedText;
                    notesBox.dataset.userEdited = 'false';
                    showNotification('Template loaded', 'success', 1500);
                    
                    // Update tag recommendations after loading template
                    analyzeNotesForTags();
                }
            } catch (error) {
                console.error('Failed to update notes:', error);
                showNotification('Failed to load template', 'error');
            }
        }

        // Enhanced clipboard functionality
        async function copyToClipboard(event, elementId) {
            const button = event.target;
            try {
                const element = document.getElementById(elementId);
                
                if (!element) {
                    throw new Error('Element not found');
                }
                
                const textToCopy = element.value.trim();
                
                if (!textToCopy) {
                    showNotification('Nothing to copy', 'error');
                    return;
                }
                
                button.disabled = true;
                button.classList.add('loading');
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    // Fallback for older browsers
                    element.select();
                    document.execCommand('copy');
                }
                
                addButtonFeedback(button, 'success');
                showNotification('Copied to clipboard!', 'success');
                
            } catch (error) {
                console.error('Copy failed:', error);
                addButtonFeedback(button, 'error');
                showNotification('Failed to copy to clipboard', 'error');
            } finally {
                button.disabled = false;
                button.classList.remove('loading');
            }
        }

        async function copyAdditionalNotes(event) {
            try {
                const button = event.target;
                const formData = getFormData();
                
                const copiedText = [];
                if (formData.techName) copiedText.push(`Technician Name: ${formData.techName}`);
                if (formData.storeNumber) copiedText.push(`Store Number: ${formData.storeNumber}`);
                if (formData.workOrder) copiedText.push(`Work Order Number: ${formData.workOrder}`);
                if (formData.notes) copiedText.push(formData.notes);
                
                // Add selected tags if any
                const selectedTags = getSelectedTags();
                if (selectedTags.length > 0) {
                    copiedText.push(`Tags: ${selectedTags.join(', ')}`);
                }

                if (copiedText.length === 0) {
                    showNotification('No data to copy', 'error');
                    button.disabled = false;
                    button.classList.remove('loading');
                    return;
                }
                
                button.disabled = true;
                button.classList.add('loading');
                const success = saveNotesHistory();
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(copiedText.join('\n'));
                } else {
                    // Fallback
                    const tempTextarea = document.createElement('textarea');
                    tempTextarea.value = copiedText.join('\n');
                    document.body.appendChild(tempTextarea);
                    tempTextarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextarea);
                }
                
                addButtonFeedback(button, 'success');
                const tagInfo = selectedTags.length > 0 ? ` (${selectedTags.length} tags included)` : '';
                showNotification(
                    success ? `Copied and saved to history!${tagInfo}` : `Copied successfully!${tagInfo}`, 
                    'success'
                );
                
            } catch (error) {
                console.error('Copy failed:', error);
                addButtonFeedback(event.target, 'error');
                showNotification('Failed to copy', 'error');
            } finally {
                const button = event.target;
                button.disabled = false;
                button.classList.remove('loading');
            }
        }

        // Enhanced form management
        function clearFormFields() {
            try {
                const fields = ['tech-name', 'store-number', 'work-order', 'notes', 'dropdown-notes'];
                fields.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) element.value = '';
                });
                
                const dropdownNotes = document.getElementById('dropdown-notes');
                if (dropdownNotes) dropdownNotes.dataset.userEdited = 'false';
                
                const selects = ['autofill', 'history'];
                selects.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.selectedIndex = 0;
                        element.value = '';
                    }
                });
                
                // Clear selected tags
                AppState.selectedTags.clear();
                displayRecommendedTags([]);
                
                showNotification('Form cleared', 'success', 1500);
                clearAutoSave();
                
            } catch (error) {
                console.error('Failed to clear form:', error);
                showNotification('Failed to clear form', 'error');
            }
        }

        function clearForm() {
            if (!confirm('This will clear all form data AND delete all saved history. Are you sure?')) {
                return;
            }
            
            try {
                clearFormFields();
                localStorage.removeItem('notesHistory');
                updateHistoryDropdown();
                showNotification('Everything cleared', 'success');
            } catch (error) {
                console.error('Failed to clear everything:', error);
                showNotification('Failed to clear everything', 'error');
            }
        }

        // Auto-save functionality
        function scheduleAutoSave() {
            clearTimeout(AppState.autoSaveTimer);
            AppState.autoSaveTimer = setTimeout(() => {
                const currentData = JSON.stringify(getFormData());
                if (currentData !== AppState.lastSavedData && hasValidData(getFormData())) {
                    saveNotesHistory();
                    AppState.lastSavedData = currentData;
                }
            }, 30000); // Auto-save after 30 seconds of inactivity
        }

        function clearAutoSave() {
            clearTimeout(AppState.autoSaveTimer);
            AppState.lastSavedData = null;
        }

        // Enhanced input validation
        function setupInputValidation() {
            const storeNumberInput = document.getElementById('store-number');
            if (storeNumberInput) {
                storeNumberInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    if (value && !/^\d+$/.test(value)) {
                        // Optionally, you can set a custom validity message here
                        // e.target.setCustomValidity('Please enter only numbers.');
                    } else {
                        e.target.setCustomValidity('');
                    }
                });
            }
            // Add auto-save only to specific text inputs and textareas (not selects)
            const formInputs = [
                document.getElementById('tech-name'),
                document.getElementById('store-number'),
                document.getElementById('work-order'),
                document.getElementById('notes'),
                document.getElementById('dropdown-notes')
            ].filter(Boolean);
            formInputs.forEach(input => {
                input.addEventListener('input', function() {
                    scheduleAutoSave();
                    // Analyze notes for tag recommendations
                    if (this.id === 'notes' || this.id === 'dropdown-notes') {
                        analyzeNotesForTags();
                    }
                });
            });
        }

        // Keyboard navigation enhancements
        function setupKeyboardNavigation() {
            // Theme toggle with keyboard
            document.addEventListener('keydown', function(e) {
                // Only trigger if not typing in an input field
                const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT';
                
                if (!isTyping) {
                    if (e.key === ' ' || e.key === 'Spacebar') {
                        e.preventDefault();
                        if (!AppState.timerRunning) {
                            startTimer();
                        }
                    }
                    
                    if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        resetTimer();
                    }
                    
                    if (e.key === 'p' || e.key === 'P') {
                        e.preventDefault();
                        pauseTimer();
                    }
                    
                    if (e.key === 'c' || e.key === 'C') {
                        e.preventDefault();
                        resetCallDetection();
                    }
                    
                    if (e.key === 'u' || e.key === 'U') {
                        e.preventDefault();
                        checkForUpdates();
                    }
                }
                
                if (e.key === 'F2') {
                    e.preventDefault();
                    toggleTheme();
                }
                
                // Quick copy with Ctrl+Shift+C
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    copyAdditionalNotes();
                }
                
                // GitHub token setup with Ctrl+Shift+G
                if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                    e.preventDefault();
                    setGitHubToken();
                }
            });
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // Set theme from localStorage
                const savedTheme = localStorage.getItem('theme');
                const isDark = savedTheme === 'dark';
                
                document.body.classList.remove('light-mode', 'dark-mode');
                document.body.classList.add(isDark ? 'dark-mode' : 'light-mode');
                updateThemeIcon(isDark);
                
                // Update theme button aria-label
                const themeButton = document.getElementById('theme-toggle-btn');
                if (themeButton) {
                    themeButton.setAttribute('aria-label', 
                        isDark ? 'Switch to light mode' : 'Switch to dark mode'
                    );
                }

                // Update history dropdown
                updateHistoryDropdown();

                // Hide static update button initially (only show when update available)
                const staticUpdateBtn = document.getElementById('update-btn');
                if (staticUpdateBtn) {
                    staticUpdateBtn.style.display = 'none';
                }

                // Setup enhanced functionality
                setupInputValidation();
                setupKeyboardNavigation();

                // Track user edits on dropdown-notes
                const dropdownNotes = document.getElementById('dropdown-notes');
                if (dropdownNotes) {
                    dropdownNotes.addEventListener('input', function() {
                        this.dataset.userEdited = 'true';
                    });
                }

                // Initialize auto-save state
                AppState.lastSavedData = JSON.stringify(getFormData());
                
                // Initialize microphone for dead air detection
                initializeMicrophone();
                
                // Initialize VCC integration
                initializeVCCIntegration();
                
                // Load saved infractions and update display
                loadTotalInfractions();
                updateInfractionDisplay();
                
                // Load saved settings and initialize GitHub token
                initializeGitHubToken();
                
                const savedAutoUpdate = localStorage.getItem('autoUpdateEnabled');
                if (savedAutoUpdate !== null) {
                    AppState.autoUpdateEnabled = savedAutoUpdate === 'true';
                }
                
                // Check for updates on startup (after 5 seconds)
                if (AppState.autoUpdateEnabled) {
                    setTimeout(() => {
                        checkForUpdates();
                    }, 5000);
                }
                
                console.log('QA Checklist App initialized successfully');
                
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('App initialization failed', 'error');
            }
        });

        // Add notification container for accessibility
        document.addEventListener('DOMContentLoaded', function() {
            const notificationContainer = document.createElement('div');
            notificationContainer.setAttribute('aria-live', 'polite');
            notificationContainer.setAttribute('aria-atomic', 'true');
            notificationContainer.className = 'sr-only';
            notificationContainer.id = 'notification-announcer';
            document.body.appendChild(notificationContainer);
        });
    </script>
